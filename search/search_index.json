{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CS4341 Game Referee","text":"<p>A modern game referee system developed for WPI's CS4341 - Introduction to Artificial Intelligence course, taught by Professor Ruiz in C Term 2025. This referee system powers both Tic-tac-toe and Lasker Morris competitions, providing a robust platform for AI development and testing.</p>"},{"location":"#overview","title":"Overview","text":"<p>The CS4341 Game Referee is designed to:</p> <ul> <li>Enforce game rules for various two-player board games</li> <li>Manage player communication via standard input/output</li> <li>Provide a rich web visualization for game monitoring</li> <li>Support tournament management with a dedicated runner</li> </ul> <p>Currently, the system supports:</p> <ul> <li>Tic-tac-toe: The classic 3x3 grid game</li> <li>Lasker Morris: A variant of Nine Men's Morris with special movement rules</li> </ul>"},{"location":"#key-features","title":"Key Features","text":"<ul> <li>Modular architecture: Easy to extend with new games</li> <li>Real-time visualization: Web-based interface for monitoring games</li> <li>Robust communication: Manages external player processes</li> <li>Error handling: Gracefully handles timeouts, crashes, and invalid moves</li> <li>Tournament support: Automated multi-round competition management</li> </ul>"},{"location":"#quick-start","title":"Quick Start","text":"<pre><code># Install the referee\npip install git+https://github.com/jake-molnia/cs4341-referee.git\n\n# Run a Tic-tac-toe game\ncs4341-referee tictactoe -p \"python your_player.py\" --visual\n\n# Run a Lasker Morris game\ncs4341-referee laskermorris -p1 \"python player1.py\" -p2 \"python player2.py\" --visual\n</code></pre>"},{"location":"#project-structure","title":"Project Structure","text":"<pre><code>cs4341-referee/\n\u251c\u2500\u2500 src/                 # Source code\n\u2502   \u251c\u2500\u2500 cli/             # Command line interface\n\u2502   \u251c\u2500\u2500 core/            # Core game logic\n\u2502   \u2502   \u251c\u2500\u2500 abstract.py  # Base game and player classes\n\u2502   \u2502   \u251c\u2500\u2500 games.py     # Game implementations\n\u2502   \u2502   \u251c\u2500\u2500 players.py   # Player implementations\n\u2502   \u2502   \u251c\u2500\u2500 utils.py     # Utility functions\n\u2502   \u2502   \u2514\u2500\u2500 web.py       # Web interface\n\u2502   \u2514\u2500\u2500 web/             # Web templates\n\u251c\u2500\u2500 tests/               # Test suite\n\u2514\u2500\u2500 tournament/          # Tournament runner\n</code></pre> <p>Visit the Getting Started section to begin using the CS4341 Game Referee.</p>"},{"location":"checking-git/","title":"Checking and Installing Git","text":"<p>This guide will help you verify and set up Git, which is required to install the CS4341 referee system.</p>"},{"location":"checking-git/#checking-git-installation","title":"Checking Git Installation","text":"<p>Open your terminal and run: <pre><code>git --version\n</code></pre></p> <p>You should see output like: <pre><code>git version 2.39.2\n</code></pre></p>"},{"location":"checking-git/#installing-git","title":"Installing Git","text":""},{"location":"checking-git/#windows","title":"Windows","text":"<ol> <li>Download Git from git-scm.com</li> <li>Run the installer</li> <li>Use recommended settings (especially \"Git from the command line and also from 3rd-party software\")</li> <li>Choose your preferred text editor (VS Code recommended)</li> <li>Select \"Use Git from Git Bash only\" or \"Use Git from the Windows Command Prompt\"</li> <li>For line endings, choose \"Checkout Windows-style, commit Unix-style\"</li> </ol>"},{"location":"checking-git/#macos","title":"macOS","text":"<p>Using Homebrew: <pre><code>brew install git\n</code></pre></p> <p>Or download from git-scm.com</p>"},{"location":"checking-git/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":"<pre><code>sudo apt update\nsudo apt install git\n</code></pre>"},{"location":"checking-git/#verifying-installation","title":"Verifying Installation","text":"<p>After installing, open a new terminal and verify: <pre><code>git --version\n</code></pre></p> <p>For additional help, consult the Git documentation or contact the course staff.</p>"},{"location":"checking-pip/","title":"Checking and Installing pip","text":"<p>This guide will help you verify and set up pip, Python's package installer, which is required for the CS4341 referee system.</p>"},{"location":"checking-pip/#checking-pip-installation","title":"Checking pip Installation","text":"<ol> <li> <p>Open your terminal and run:    <pre><code>pip --version\n# or\npip3 --version\n</code></pre></p> </li> <li> <p>You should see output like:    <pre><code>pip 23.1.2 from /usr/local/lib/python3.10/site-packages/pip (python 3.10)\n</code></pre></p> </li> </ol>"},{"location":"checking-pip/#installing-pip","title":"Installing pip","text":""},{"location":"checking-pip/#windows","title":"Windows","text":"<ol> <li>pip usually comes with Python installation. If missing:    <pre><code>python -m ensurepip --upgrade\n</code></pre></li> </ol>"},{"location":"checking-pip/#macoslinux","title":"macOS/Linux","text":"<pre><code>python3 -m ensurepip --upgrade\n# or\nsudo apt install python3-pip  # Ubuntu/Debian\nbrew install pip  # macOS with Homebrew\n</code></pre>"},{"location":"checking-pip/#upgrading-pip","title":"Upgrading pip","text":"<p>It's recommended to keep pip updated: <pre><code>python -m pip install --upgrade pip\n# or\npip install --upgrade pip\n</code></pre></p>"},{"location":"checking-pip/#multiple-python-versions","title":"Multiple Python Versions","text":"<p>If you have multiple Python versions: 1. Use the specific version's pip:    <pre><code>python3.10 -m pip install &lt;package&gt;\n</code></pre> 2. Or use virtual environments (recommended):    <pre><code>python -m venv myenv\nsource myenv/bin/activate  # Unix/macOS\nmyenv\\Scripts\\activate     # Windows\npip install &lt;package&gt;\n</code></pre></p>"},{"location":"checking-pip/#verifying-installation","title":"Verifying Installation","text":"<p>After adding to PATH or installing, verify with: <pre><code>pip --version\ncs4341-referee --help  # After installing the referee\n</code></pre></p> <p>For additional help, consult the pip documentation or contact the course staff.</p>"},{"location":"checking-python-version/","title":"Checking Your Python Version","text":"<p>This guide will help you verify that you have Python 3.9 or higher installed on your system, which is required to run the CS4341 referee system.</p>"},{"location":"checking-python-version/#command-line-method","title":"Command Line Method","text":"<ol> <li> <p>Open your terminal (Command Prompt on Windows, Terminal on macOS/Linux)</p> </li> <li> <p>Run one of these commands:    <pre><code>python --version\n# or\npython3 --version\n</code></pre></p> </li> <li> <p>You should see output like:    <pre><code>Python 3.10.8\n</code></pre>    Make sure the version number is 3.10.0 or higher.</p> </li> </ol>"},{"location":"checking-python-version/#checking-in-python","title":"Checking in Python","text":"<p>You can also check your version from within Python:</p> <ol> <li> <p>Open Python in interactive mode:    <pre><code>python\n# or\npython3\n</code></pre></p> </li> <li> <p>Run this code:    <pre><code>import sys\nprint(sys.version)\n</code></pre></p> </li> <li> <p>You'll see detailed version information like:    <pre><code>3.10.8 (main, Oct 13 2022, 10:17:43) [Clang 14.0.0 (clang-1400.0.29.102)]\n</code></pre></p> </li> </ol>"},{"location":"checking-python-version/#installing-or-updating-python","title":"Installing or Updating Python","text":"<p>If you don't have Python 3.9+ installed:</p>"},{"location":"checking-python-version/#windows","title":"Windows","text":"<ol> <li>Visit the Python Downloads page</li> <li>Download the latest Python 3 installer</li> <li>Run the installer, making sure to check \"Add Python to PATH\"</li> </ol>"},{"location":"checking-python-version/#macos","title":"macOS","text":"<p>Using Homebrew: <pre><code>brew install python@3.12\n</code></pre></p>"},{"location":"checking-python-version/#linux-ubuntudebian","title":"Linux (Ubuntu/Debian)","text":"<pre><code>sudo apt update\nsudo apt install python3.12\n</code></pre>"},{"location":"checking-python-version/#multiple-python-versions","title":"Multiple Python Versions","text":"<p>If you have multiple Python versions installed:</p> <ol> <li> <p>You can specify the version explicitly:    <pre><code>python3.9 --version\npython3.10 --version\n</code></pre></p> </li> <li> <p>Consider using virtual environments to manage different Python versions:    <pre><code># Create a virtual environment with specific Python version\npython3.10 -m venv myenv\n\n# Activate it\nsource myenv/bin/activate  # On Unix/macOS\nmyenv\\Scripts\\activate     # On Windows\n</code></pre></p> </li> </ol>"},{"location":"checking-python-version/#troubleshooting","title":"Troubleshooting","text":"<p>If you see an error like \"python not found\" or get a version lower than 3.10:</p> <ol> <li>Make sure Python is properly installed</li> <li>Check if Python is added to your system's PATH</li> <li>Try using <code>python3</code> instead of <code>python</code></li> <li>On Windows, try using <code>py -3</code> or <code>py -3.10</code></li> </ol> <p>For additional help, consult the Python Installation Guide or contact the course staff.</p>"},{"location":"api/abstract-game/","title":"AbstractGame","text":"<p><code>AbstractGame</code> is the core abstract base class that defines the interface for all game implementations in the CS4341 Game Referee system. It provides the essential structure for turn-based games between two players.</p>"},{"location":"api/abstract-game/#class-definition","title":"Class Definition","text":"<pre><code>class AbstractGame(ABC):\n    \"\"\"Abstract base class for turn-based games between two players.\"\"\"\n\n    def __init__(self, player1: AbstractPlayer, player2: AbstractPlayer) -&gt; None:\n        self._player1 = player1\n        self._player2 = player2\n        self._current_player = player1\n        self._is_game_over = False\n\n    @property\n    def current_player(self) -&gt; AbstractPlayer:\n        return self._current_player\n\n    def switch_player(self) -&gt; None:\n        self._current_player = self._player2 if self._current_player == self._player1 else self._player1\n\n    @property\n    def is_game_over(self) -&gt; bool:\n        return self._is_game_over\n\n    @abstractmethod\n    def initialize_game(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    def make_move(self, move: Any) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def determine_winner(self) -&gt; Optional[AbstractPlayer]:\n        pass\n</code></pre>"},{"location":"api/abstract-game/#properties","title":"Properties","text":""},{"location":"api/abstract-game/#current_player","title":"current_player","text":"<p>Returns the player whose turn it is currently.</p> <p>Return type: <code>AbstractPlayer</code></p>"},{"location":"api/abstract-game/#is_game_over","title":"is_game_over","text":"<p>Indicates whether the game has ended.</p> <p>Return type: <code>bool</code></p>"},{"location":"api/abstract-game/#methods","title":"Methods","text":""},{"location":"api/abstract-game/#__init__player1-player2","title":"__init__(player1, player2)","text":"<p>Initializes a new game instance with two players.</p> <p>Parameters:</p> <ul> <li><code>player1</code> (AbstractPlayer): The first player</li> <li><code>player2</code> (AbstractPlayer): The second player</li> </ul>"},{"location":"api/abstract-game/#switch_player","title":"switch_player()","text":"<p>Switches the current player to the other player.</p> <p>Return type: <code>None</code></p>"},{"location":"api/abstract-game/#initialize_game","title":"initialize_game()","text":"<p>Abstract method that must be implemented by game classes. Sets up the initial game state.</p> <p>Return type: <code>None</code></p>"},{"location":"api/abstract-game/#make_movemove","title":"make_move(move)","text":"<p>Abstract method that must be implemented by game classes. Validates and executes a move.</p> <p>Parameters:</p> <ul> <li><code>move</code> (Any): The move to execute, format depends on the specific game</li> </ul> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the move was valid and executed successfully</li> <li><code>False</code> if the move was invalid</li> </ul>"},{"location":"api/abstract-game/#determine_winner","title":"determine_winner()","text":"<p>Abstract method that must be implemented by game classes. Checks the current game state to determine if there's a winner.</p> <p>Return type: <code>Optional[AbstractPlayer]</code></p> <ul> <li>The winning player if there is one</li> <li><code>None</code> if the game is a draw or not yet over</li> </ul>"},{"location":"api/abstract-game/#usage-example","title":"Usage Example","text":"<p>Game implementations must inherit from <code>AbstractGame</code> and implement all abstract methods:</p> <pre><code>class TicTacToe(AbstractGame):\n    def initialize_game(self) -&gt; None:\n        # Initialize empty board\n        self.board = {f\"{col}{row}\": None for col in \"abc\" for row in \"123\"}\n\n        # Start player processes\n        self._player1.start()\n        self._player2.start()\n\n        # Notify players of their symbols\n        self._player1.write(\"X\")\n        self._player2.write(\"O\")\n\n    def make_move(self, move: str) -&gt; bool:\n        # Validate move format\n        if not self._validate_move_format(move):\n            return False\n\n        # Check if position is empty\n        if self.board[move] is not None:\n            return False\n\n        # Execute the move\n        self.board[move] = self._current_player.get_symbol()\n        return True\n\n    def determine_winner(self) -&gt; Optional[AbstractPlayer]:\n        # Check win conditions\n        winning_symbol = self._check_winner()\n        if winning_symbol:\n            self._is_game_over = True\n            return (\n                self._player1 if self._player1.get_symbol() == winning_symbol\n                else self._player2\n            )\n\n        # Check for draw\n        if self._is_board_full():\n            self._is_game_over = True\n            return None\n\n        return None\n</code></pre>"},{"location":"api/abstract-game/#implementation-guidelines","title":"Implementation Guidelines","text":"<p>When implementing the <code>AbstractGame</code> class, follow these guidelines:</p> <ol> <li> <p>State Management: Maintain the game state, including the board, player information, and move history.</p> </li> <li> <p>Player Communication: Handle communication with player processes through the <code>AbstractPlayer</code> interface.</p> </li> <li> <p>Move Validation: Implement thorough validation for player moves according to game rules.</p> </li> <li> <p>Win Detection: Implement logic to detect win conditions and determine the winner.</p> </li> <li> <p>Draw Detection: Implement logic to detect when a game ends in a draw.</p> </li> <li> <p>Error Handling: Handle player timeouts, invalid moves, and other potential issues.</p> </li> <li> <p>Visualization Support: Provide necessary hooks for the web visualization system.</p> </li> </ol>"},{"location":"api/abstract-game/#extending-abstractgame","title":"Extending AbstractGame","text":"<p>To create a new game:</p> <ol> <li>Inherit from <code>AbstractGame</code></li> <li>Implement all abstract methods</li> <li>Add game-specific state and logic</li> <li>Create corresponding player and web visualization classes</li> <li>Register your game with the CLI system</li> </ol>"},{"location":"api/abstract-game/#notes","title":"Notes","text":"<ul> <li> <p>The <code>AbstractGame</code> class does not include a default implementation of <code>run_game()</code>. Each game typically provides its own implementation of the main game loop, handling the specifics of player interaction and game progression.</p> </li> <li> <p>Game-specific player classes (like <code>TicTacToePlayer</code>) should inherit from <code>AbstractPlayer</code> and be used by the game implementation.</p> </li> <li> <p>Consider using the <code>_get_move_with_timeout()</code> pattern seen in existing games to handle move timeouts gracefully.</p> </li> </ul>"},{"location":"api/abstract-player/","title":"Coming Soon","text":"<p>This documentation is currently being developed.</p>"},{"location":"api/players/","title":"Players","text":"<p>The CS4341 Game Referee system includes game-specific player classes that extend the <code>AbstractPlayer</code> base class. These player classes handle the specifics of player symbols, colors, and game-specific functionality.</p>"},{"location":"api/players/#player-class-hierarchy","title":"Player Class Hierarchy","text":"<pre><code>AbstractPlayer (Abstract Base Class)\n\u251c\u2500\u2500 TicTacToePlayer\n\u2514\u2500\u2500 LaskerPlayer\n</code></pre>"},{"location":"api/players/#tictactoeplayer","title":"TicTacToePlayer","text":"<p>The <code>TicTacToePlayer</code> class represents a player in the Tic-tac-toe game.</p>"},{"location":"api/players/#class-definition","title":"Class Definition","text":"<pre><code>class TicTacToePlayer(AbstractPlayer):\n    \"\"\"Player implementation for Tic-tac-toe game.\"\"\"\n\n    def __init__(self, command: str, symbol: str, log: bool = False):\n        super().__init__(command, log)\n        try:\n            self.symbol = PlayerSymbol(symbol.upper())\n        except ValueError:\n            raise ValueError(f\"Invalid symbol: {symbol}. Must be either 'blue' or 'orange'\")\n\n    def get_symbol(self) -&gt; str:\n        return self.symbol.value\n\n    def is_x(self) -&gt; bool:\n        return self.symbol == PlayerSymbol.X\n\n    def is_o(self) -&gt; bool:\n        return self.symbol == PlayerSymbol.O\n</code></pre>"},{"location":"api/players/#attributes","title":"Attributes","text":"Attribute Type Description <code>symbol</code> <code>PlayerSymbol</code> Player's symbol (X or O)"},{"location":"api/players/#methods","title":"Methods","text":""},{"location":"api/players/#get_symbol","title":"get_symbol()","text":"<p>Gets the player's symbol.</p> <p>Return type: <code>str</code></p> <ul> <li>The player's symbol as a string (\"BLUE\" for X or \"ORANGE\" for O)</li> </ul>"},{"location":"api/players/#is_x","title":"is_x()","text":"<p>Checks if the player is X.</p> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the player is X, <code>False</code> otherwise</li> </ul>"},{"location":"api/players/#is_o","title":"is_o()","text":"<p>Checks if the player is O.</p> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the player is O, <code>False</code> otherwise</li> </ul>"},{"location":"api/players/#symbol-enum","title":"Symbol Enum","text":"<p>The player symbols are defined in an enum:</p> <pre><code>class PlayerSymbol(Enum):\n    \"\"\"Enum for valid player symbols in TicTacToe.\"\"\"\n    X = \"BLUE\"\n    O = \"ORANGE\"\n</code></pre>"},{"location":"api/players/#laskerplayer","title":"LaskerPlayer","text":"<p>The <code>LaskerPlayer</code> class represents a player in the Lasker Morris game.</p>"},{"location":"api/players/#class-definition_1","title":"Class Definition","text":"<pre><code>class LaskerPlayer(AbstractPlayer):\n    \"\"\"Player implementation for Lasker Morris game.\"\"\"\n\n    def __init__(self, command: str, color: str, log: bool = False, debug: bool = False):\n        super().__init__(command, log, debug)\n        try:\n            self.color = PlayerColor(color.lower())\n        except ValueError:\n            raise ValueError(f\"Invalid color: {color}. Must be either 'blue' or 'orange'\")\n\n    def get_color(self) -&gt; str:\n        return self.color.value\n\n    def is_blue(self) -&gt; bool:\n        return self.color == PlayerColor.BLUE\n\n    def is_orange(self) -&gt; bool:\n        return self.color == PlayerColor.ORANGE\n</code></pre>"},{"location":"api/players/#attributes_1","title":"Attributes","text":"Attribute Type Description <code>color</code> <code>PlayerColor</code> Player's color (blue or orange)"},{"location":"api/players/#methods_1","title":"Methods","text":""},{"location":"api/players/#get_color","title":"get_color()","text":"<p>Gets the player's color.</p> <p>Return type: <code>str</code></p> <ul> <li>The player's color as a string (\"blue\" or \"orange\")</li> </ul>"},{"location":"api/players/#is_blue","title":"is_blue()","text":"<p>Checks if the player is blue.</p> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the player is blue, <code>False</code> otherwise</li> </ul>"},{"location":"api/players/#is_orange","title":"is_orange()","text":"<p>Checks if the player is orange.</p> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the player is orange, <code>False</code> otherwise</li> </ul>"},{"location":"api/players/#color-enum","title":"Color Enum","text":"<p>The player colors are defined in an enum:</p> <pre><code>class PlayerColor(Enum):\n    \"\"\"Enum for valid player colors in Lasker Morris.\"\"\"\n    BLUE = \"blue\"\n    ORANGE = \"orange\"\n</code></pre>"},{"location":"api/players/#usage-examples","title":"Usage Examples","text":""},{"location":"api/players/#tictactoeplayer_1","title":"TicTacToePlayer","text":"<pre><code># Create a TicTacToe player with the X symbol\nplayer = TicTacToePlayer(\"python player.py\", \"blue\", log=True)\n\n# Start the player process\nplayer.start()\n\n# Send initial symbol\nplayer.write(\"blue\")\n\n# Read a move from the player\nmove = player.read()\nprint(f\"Player moved: {move}\")\n\n# Check if player is X\nif player.is_x():\n    print(\"Player is X\")\nelse:\n    print(\"Player is O\")\n\n# Get player's symbol\nsymbol = player.get_symbol()\nprint(f\"Player's symbol: {symbol}\")\n\n# Stop the player process\nplayer.stop()\n</code></pre>"},{"location":"api/players/#laskerplayer_1","title":"LaskerPlayer","text":"<pre><code># Create a Lasker Morris player with the blue color\nplayer = LaskerPlayer(\"python player.py\", \"blue\", log=True, debug=True)\n\n# Start the player process\nplayer.start()\n\n# Send initial color\nplayer.write(\"blue\")\n\n# Read a move from the player\nmove = player.read()\nprint(f\"Player moved: {move}\")\n\n# Check if player is blue\nif player.is_blue():\n    print(\"Player is blue\")\nelse:\n    print(\"Player is orange\")\n\n# Get player's color\ncolor = player.get_color()\nprint(f\"Player's color: {color}\")\n\n# Stop the player process\nplayer.stop()\n</code></pre>"},{"location":"api/players/#player-process-communication","title":"Player Process Communication","text":"<p>The player classes communicate with external processes via standard input/output:</p> <ol> <li>Start: The player process is started with the specified command.</li> <li>Initialization: The player receives its symbol or color.</li> <li>Move Requests: The player reads the opponent's move and responds with its own move.</li> <li>Termination: The player process is terminated when the game ends.</li> </ol>"},{"location":"api/players/#inputoutput-format","title":"Input/Output Format","text":"<p>The player process communicates with the referee through text:</p> <ul> <li> <p>Input (referee to player):</p> </li> <li> <p>First input: Player's symbol or color</p> </li> <li> <p>Subsequent inputs: Opponent's move or empty string for first move</p> </li> <li> <p>Output (player to referee):</p> </li> <li>Player's move in the appropriate format for the game</li> </ul>"},{"location":"api/players/#exception-handling","title":"Exception Handling","text":"<p>The player classes include validation to ensure that valid symbols and colors are used:</p> <pre><code>try:\n    self.color = PlayerColor(color.lower())\nexcept ValueError:\n    raise ValueError(f\"Invalid color: {color}. Must be either 'blue' or 'orange'\")\n</code></pre> <p>This validation helps prevent issues with invalid player attributes.</p>"},{"location":"api/players/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>Player classes extend <code>AbstractPlayer</code> to inherit process management functionality</li> <li>Game-specific attributes (symbols, colors) are encapsulated in the player classes</li> <li>Enums are used to restrict valid symbols and colors</li> <li>Helper methods provide convenient ways to check player properties</li> <li>Error handling ensures valid player initialization</li> </ul>"},{"location":"api/utilities/","title":"Utilities","text":"<p>The CS4341 Game Referee system includes several utility classes and functions that support game implementations. These utilities handle common tasks such as error management, logging, and board operations.</p>"},{"location":"api/utilities/#error-classes","title":"Error Classes","text":"<p>The system defines several custom exception classes for specific error scenarios:</p>"},{"location":"api/utilities/#gameerror","title":"GameError","text":"<p>Base class for all game-related errors.</p> <pre><code>class GameError(Exception):\n    \"\"\"Base class for game-related errors\"\"\"\n    pass\n</code></pre>"},{"location":"api/utilities/#invalidmoveerror","title":"InvalidMoveError","text":"<p>Error raised when a player makes an invalid move.</p> <pre><code>class InvalidMoveError(GameError):\n    \"\"\"Error raised when a move is invalid\"\"\"\n    pass\n</code></pre>"},{"location":"api/utilities/#timeouterror","title":"TimeoutError","text":"<p>Error raised when a player takes too long to respond.</p> <pre><code>class TimeoutError(GameError):\n    \"\"\"Error raised when a player takes too long to respond\"\"\"\n    pass\n</code></pre>"},{"location":"api/utilities/#gamelogger","title":"GameLogger","text":"<p>The <code>GameLogger</code> class provides a standardized logging interface for games.</p>"},{"location":"api/utilities/#class-definition","title":"Class Definition","text":"<pre><code>class GameLogger:\n    \"\"\"Handles logging for games\"\"\"\n\n    def __init__(self, name: str, enable_logging: bool = False):\n        self.logger = logging.getLogger(name)\n        if enable_logging:\n            self._setup_logging()\n\n    def _setup_logging(self) -&gt; None:\n        handler = logging.FileHandler(f\"{self.logger.name}.log\")\n        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')\n        handler.setFormatter(formatter)\n        self.logger.addHandler(handler)\n        self.logger.setLevel(logging.INFO)\n\n    def info(self, message: str) -&gt; None:\n        self.logger.info(message)\n\n    def error(self, message: str) -&gt; None:\n        self.logger.error(message)\n\n    def debug(self, message: str) -&gt; None:\n        self.logger.debug(message)\n</code></pre>"},{"location":"api/utilities/#methods","title":"Methods","text":""},{"location":"api/utilities/#__init__name-enable_loggingfalse","title":"__init__(name, enable_logging=False)","text":"<p>Initializes a new logger instance.</p> <p>Parameters:</p> <ul> <li><code>name</code> (str): Name of the logger (typically the game name)</li> <li><code>enable_logging</code> (bool): Whether to enable logging (default: False)</li> </ul>"},{"location":"api/utilities/#_setup_logging","title":"_setup_logging()","text":"<p>Internal method to set up logging handlers and formatters.</p> <p>Return type: <code>None</code></p>"},{"location":"api/utilities/#infomessage","title":"info(message)","text":"<p>Logs an informational message.</p> <p>Parameters:</p> <ul> <li><code>message</code> (str): The message to log</li> </ul> <p>Return type: <code>None</code></p>"},{"location":"api/utilities/#errormessage","title":"error(message)","text":"<p>Logs an error message.</p> <p>Parameters:</p> <ul> <li><code>message</code> (str): The error message to log</li> </ul> <p>Return type: <code>None</code></p>"},{"location":"api/utilities/#debugmessage","title":"debug(message)","text":"<p>Logs a debug message.</p> <p>Parameters:</p> <ul> <li><code>message</code> (str): The debug message to log</li> </ul> <p>Return type: <code>None</code></p>"},{"location":"api/utilities/#boardutils","title":"BoardUtils","text":"<p>The <code>BoardUtils</code> class provides static methods for common board operations.</p>"},{"location":"api/utilities/#class-definition_1","title":"Class Definition","text":"<pre><code>class BoardUtils:\n    @staticmethod\n    def create_empty_board(cols: str, rows: str) -&gt; Dict[str, Optional[str]]:\n        \"\"\"Create an empty game board with given columns and rows\"\"\"\n        return {f\"{col}{row}\": None for col in cols for row in rows}\n\n    @staticmethod\n    def is_position_empty(board: Dict[str, Optional[str]], position: str) -&gt; bool:\n        \"\"\"Check if a board position is empty\"\"\"\n        return position in board and board[position] is None\n\n    @staticmethod\n    def is_position_valid(board: Dict[str, Optional[str]],\n                         position: str,\n                         invalid_fields: Optional[Set[str]] = None) -&gt; bool:\n        \"\"\"Check if a position is valid on the board\"\"\"\n        if invalid_fields and position in invalid_fields:\n            return False\n        return position in board\n</code></pre>"},{"location":"api/utilities/#methods_1","title":"Methods","text":""},{"location":"api/utilities/#create_empty_boardcols-rows","title":"create_empty_board(cols, rows)","text":"<p>Creates an empty game board with the specified columns and rows.</p> <p>Parameters:</p> <ul> <li><code>cols</code> (str): String containing valid column identifiers (e.g., \"abc\")</li> <li><code>rows</code> (str): String containing valid row identifiers (e.g., \"123\")</li> </ul> <p>Return type: <code>Dict[str, Optional[str]]</code></p> <ul> <li>A dictionary representing the empty board</li> </ul>"},{"location":"api/utilities/#is_position_emptyboard-position","title":"is_position_empty(board, position)","text":"<p>Checks if a position on the board is empty.</p> <p>Parameters:</p> <ul> <li><code>board</code> (Dict[str, Optional[str]]): The board state</li> <li><code>position</code> (str): The position to check</li> </ul> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the position is empty</li> <li><code>False</code> if the position is occupied or invalid</li> </ul>"},{"location":"api/utilities/#is_position_validboard-position-invalid_fieldsnone","title":"is_position_valid(board, position, invalid_fields=None)","text":"<p>Checks if a position is valid on the board.</p> <p>Parameters:</p> <ul> <li><code>board</code> (Dict[str, Optional[str]]): The board state</li> <li><code>position</code> (str): The position to check</li> <li><code>invalid_fields</code> (Optional[Set[str]]): Set of invalid positions (optional)</li> </ul> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the position is valid</li> <li><code>False</code> if the position is invalid</li> </ul>"},{"location":"api/utilities/#usage-examples","title":"Usage Examples","text":""},{"location":"api/utilities/#error-handling","title":"Error Handling","text":"<pre><code>try:\n    # Attempt to make a move\n    if not game.make_move(move):\n        raise InvalidMoveError(f\"Invalid move: {move}\")\n\n    # Check for timeout\n    if timeout_occurred:\n        raise TimeoutError(\"Player took too long to respond\")\n\nexcept InvalidMoveError as e:\n    print(f\"Move error: {e}\")\n    # Handle invalid move\n\nexcept TimeoutError as e:\n    print(f\"Timeout error: {e}\")\n    # Handle timeout\n\nexcept GameError as e:\n    print(f\"Game error: {e}\")\n    # Handle other game errors\n</code></pre>"},{"location":"api/utilities/#logging","title":"Logging","text":"<pre><code># Create a logger for a Tic-tac-toe game\nlogger = GameLogger(\"tictactoe\", enable_logging=True)\n\n# Log game events\nlogger.info(\"Game started\")\nlogger.info(f\"Player 1: {player1_command}\")\nlogger.info(f\"Player 2: {player2_command}\")\n\n# Log moves\nlogger.info(f\"Player 1 moved: {move}\")\n\n# Log errors\ntry:\n    # Game logic\n    pass\nexcept Exception as e:\n    logger.error(f\"Error occurred: {str(e)}\")\n\n# Log debug information\nlogger.debug(f\"Current board state: {board}\")\n</code></pre>"},{"location":"api/utilities/#board-utilities","title":"Board Utilities","text":"<pre><code># Create an empty Tic-tac-toe board\nboard = BoardUtils.create_empty_board(\"abc\", \"123\")\nprint(board)  # {'a1': None, 'a2': None, 'a3': None, 'b1': None, ...}\n\n# Check if a position is empty\nif BoardUtils.is_position_empty(board, \"b2\"):\n    print(\"Center position is empty\")\n\n# Check if a position is valid\ninvalid_fields = {\"a2\", \"a3\", \"b1\", \"c2\"}  # Example invalid fields\nif BoardUtils.is_position_valid(board, \"a1\", invalid_fields):\n    print(\"Position a1 is valid\")\nelse:\n    print(\"Position a1 is invalid\")\n</code></pre>"},{"location":"api/utilities/#integration-with-games","title":"Integration with Games","text":"<p>These utilities are designed to be used by game implementations to handle common tasks:</p>"},{"location":"api/utilities/#error-handling-in-game-loop","title":"Error Handling in Game Loop","text":"<pre><code>def run_game(self) -&gt; Optional[AbstractPlayer]:\n    \"\"\"Main game loop.\"\"\"\n    while not self.is_game_over:\n        try:\n            move = self._get_move_with_timeout()\n\n            # Handle timeout\n            if move is None:\n                raise TimeoutError(f\"Player {self.current_player.get_symbol()} timed out\")\n\n            # Handle invalid move\n            if not self.make_move(move):\n                raise InvalidMoveError(f\"Invalid move: {move}\")\n\n            # Continue game logic...\n\n        except TimeoutError as e:\n            # Handle timeout\n            self._is_game_over = True\n            return self._player2 if self.current_player == self._player1 else self._player1\n\n        except InvalidMoveError as e:\n            # Handle invalid move\n            self._is_game_over = True\n            return self._player2 if self.current_player == self._player1 else self._player1\n\n        except GameError as e:\n            # Handle other game errors\n            self._is_game_over = True\n            return None\n</code></pre>"},{"location":"api/utilities/#creating-game-boards","title":"Creating Game Boards","text":"<pre><code>def initialize_game(self) -&gt; None:\n    \"\"\"Initialize the game state.\"\"\"\n    # Create empty board\n    self.board = BoardUtils.create_empty_board(self.VALID_COLUMNS, self.VALID_ROWS)\n\n    # Start player processes\n    self._player1.start()\n    self._player2.start()\n\n    # Start web server\n    if self.visual and self.web:\n        self.web.start_web_server(self.port)\n\n    # Send initial player information\n    self._player1.write(self._player1.get_symbol())\n    self._player2.write(self._player2.get_symbol())\n</code></pre>"},{"location":"api/utilities/#validating-moves","title":"Validating Moves","text":"<pre><code>def make_move(self, move: str) -&gt; bool:\n    \"\"\"Process a player's move.\"\"\"\n    # Validate move format\n    is_valid, error_msg = self._validate_move_format(move)\n    if not is_valid:\n        return False\n\n    # Check if position is empty\n    if not BoardUtils.is_position_empty(self.board, move):\n        return False\n\n    # Execute the move\n    self.board[move] = self.current_player.get_symbol()\n    self.move_history.append(move)\n\n    return True\n</code></pre>"},{"location":"api/utilities/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>The error classes follow Python's exception hierarchy</li> <li>The logger provides standardized logging with configurable output</li> <li>The board utilities handle common operations independent of specific game rules</li> <li>These utilities help maintain consistency across different game implementations</li> <li>Using these utilities can reduce code duplication and improve maintainability</li> </ul>"},{"location":"api/web-game/","title":"AbstractGame","text":"<p><code>AbstractGame</code> is the core abstract base class that defines the interface for all game implementations in the CS4341 Game Referee system. It provides the essential structure for turn-based games between two players.</p>"},{"location":"api/web-game/#class-definition","title":"Class Definition","text":"<pre><code>class AbstractGame(ABC):\n    \"\"\"Abstract base class for turn-based games between two players.\"\"\"\n\n    def __init__(self, player1: AbstractPlayer, player2: AbstractPlayer) -&gt; None:\n        self._player1 = player1\n        self._player2 = player2\n        self._current_player = player1\n        self._is_game_over = False\n\n    @property\n    def current_player(self) -&gt; AbstractPlayer:\n        return self._current_player\n\n    def switch_player(self) -&gt; None:\n        self._current_player = self._player2 if self._current_player == self._player1 else self._player1\n\n    @property\n    def is_game_over(self) -&gt; bool:\n        return self._is_game_over\n\n    @abstractmethod\n    def initialize_game(self) -&gt; None:\n        pass\n\n    @abstractmethod\n    def make_move(self, move: Any) -&gt; bool:\n        pass\n\n    @abstractmethod\n    def determine_winner(self) -&gt; Optional[AbstractPlayer]:\n        pass\n</code></pre>"},{"location":"api/web-game/#properties","title":"Properties","text":""},{"location":"api/web-game/#current_player","title":"current_player","text":"<p>Returns the player whose turn it is currently.</p> <p>Return type: <code>AbstractPlayer</code></p>"},{"location":"api/web-game/#is_game_over","title":"is_game_over","text":"<p>Indicates whether the game has ended.</p> <p>Return type: <code>bool</code></p>"},{"location":"api/web-game/#methods","title":"Methods","text":""},{"location":"api/web-game/#__init__player1-player2","title":"__init__(player1, player2)","text":"<p>Initializes a new game instance with two players.</p> <p>Parameters:</p> <ul> <li><code>player1</code> (AbstractPlayer): The first player</li> <li><code>player2</code> (AbstractPlayer): The second player</li> </ul>"},{"location":"api/web-game/#switch_player","title":"switch_player()","text":"<p>Switches the current player to the other player.</p> <p>Return type: <code>None</code></p>"},{"location":"api/web-game/#initialize_game","title":"initialize_game()","text":"<p>Abstract method that must be implemented by game classes. Sets up the initial game state.</p> <p>Return type: <code>None</code></p>"},{"location":"api/web-game/#make_movemove","title":"make_move(move)","text":"<p>Abstract method that must be implemented by game classes. Validates and executes a move.</p> <p>Parameters:</p> <ul> <li><code>move</code> (Any): The move to execute, format depends on the specific game</li> </ul> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the move was valid and executed successfully</li> <li><code>False</code> if the move was invalid</li> </ul>"},{"location":"api/web-game/#determine_winner","title":"determine_winner()","text":"<p>Abstract method that must be implemented by game classes. Checks the current game state to determine if there's a winner.</p> <p>Return type: <code>Optional[AbstractPlayer]</code></p> <ul> <li>The winning player if there is one</li> <li><code>None</code> if the game is a draw or not yet over</li> </ul>"},{"location":"api/web-game/#usage-example","title":"Usage Example","text":"<p>Game implementations must inherit from <code>AbstractGame</code> and implement all abstract methods:</p> <pre><code>class TicTacToe(AbstractGame):\n    def initialize_game(self) -&gt; None:\n        # Initialize empty board\n        self.board = {f\"{col}{row}\": None for col in \"abc\" for row in \"123\"}\n\n        # Start player processes\n        self._player1.start()\n        self._player2.start()\n\n        # Notify players of their symbols\n        self._player1.write(\"X\")\n        self._player2.write(\"O\")\n\n    def make_move(self, move: str) -&gt; bool:\n        # Validate move format\n        if not self._validate_move_format(move):\n            return False\n\n        # Check if position is empty\n        if self.board[move] is not None:\n            return False\n\n        # Execute the move\n        self.board[move] = self._current_player.get_symbol()\n        return True\n\n    def determine_winner(self) -&gt; Optional[AbstractPlayer]:\n        # Check win conditions\n        winning_symbol = self._check_winner()\n        if winning_symbol:\n            self._is_game_over = True\n            return (\n                self._player1 if self._player1.get_symbol() == winning_symbol\n                else self._player2\n            )\n\n        # Check for draw\n        if self._is_board_full():\n            self._is_game_over = True\n            return None\n\n        return None\n</code></pre>"},{"location":"api/web-game/#implementation-guidelines","title":"Implementation Guidelines","text":"<p>When implementing the <code>AbstractGame</code> class, follow these guidelines:</p> <ol> <li> <p>State Management: Maintain the game state, including the board, player information, and move history.</p> </li> <li> <p>Player Communication: Handle communication with player processes through the <code>AbstractPlayer</code> interface.</p> </li> <li> <p>Move Validation: Implement thorough validation for player moves according to game rules.</p> </li> <li> <p>Win Detection: Implement logic to detect win conditions and determine the winner.</p> </li> <li> <p>Draw Detection: Implement logic to detect when a game ends in a draw.</p> </li> <li> <p>Error Handling: Handle player timeouts, invalid moves, and other potential issues.</p> </li> <li> <p>Visualization Support: Provide necessary hooks for the web visualization system.</p> </li> </ol>"},{"location":"api/web-game/#extending-abstractgame","title":"Extending AbstractGame","text":"<p>To create a new game:</p> <ol> <li>Inherit from <code>AbstractGame</code></li> <li>Implement all abstract methods</li> <li>Add game-specific state and logic</li> <li>Create corresponding player and web visualization classes</li> <li>Register your game with the CLI system</li> </ol>"},{"location":"api/web-game/#notes","title":"Notes","text":"<ul> <li> <p>The <code>AbstractGame</code> class does not include a default implementation of <code>run_game()</code>. Each game typically provides its own implementation of the main game loop, handling the specifics of player interaction and game progression.</p> </li> <li> <p>Game-specific player classes (like <code>TicTacToePlayer</code>) should inherit from <code>AbstractPlayer</code> and be used by the game implementation.</p> </li> <li> <p>Consider using the <code>_get_move_with_timeout()</code> pattern seen in existing games to handle move timeouts gracefully.</p> </li> </ul>"},{"location":"api/games/laskermorris/","title":"LaskerMorris","text":"<p>The <code>LaskerMorris</code> class implements the Lasker Morris game for the CS4341 Game Referee system. This class extends <code>AbstractGame</code> and provides a comprehensive implementation of Lasker Morris rules, including piece placement, movement, mill formation, capturing, and win conditions.</p>"},{"location":"api/games/laskermorris/#class-definition","title":"Class Definition","text":"<pre><code>class LaskerMorris(AbstractGame):\n    \"\"\"Implementation of Lasker Morris game.\"\"\"\n\n    def __init__(\n        self,\n        player1_command: str,\n        player2_command: str,\n        visual: bool = True,\n        select_rand: bool = True,\n        timeout: int = 5,\n        debug: bool = False,\n        logging: bool = False,\n        port: int = 8000,\n        print_board: bool = False\n    ):\n        # Initialize game state and players\n\n    def _create_web_interface(self):\n        from .web import LaskerMorrisWeb\n        return LaskerMorrisWeb(self)\n\n    def initialize_game(self) -&gt; None:\n        # Set up initial game state\n\n    def make_move(self, move: str) -&gt; bool:\n        # Process and execute a player's move\n\n    def _has_valid_moves(self, player_color: str) -&gt; bool:\n        # Check if player has valid moves available\n\n    def _is_oscillating_moves(self) -&gt; bool:\n        # Check for repetitive moves (draw condition)\n\n    def _is_valid_move(self, source: str, target: str, remove: str) -&gt; bool:\n        # Validate move against game rules\n\n    def _position_is_in_mill(self, position: str, color: str) -&gt; bool:\n        # Check if a position is part of a mill\n\n    def _count_stones_outside_mills(self, color: str) -&gt; int:\n        # Count number of stones not part of any mill\n\n    def _is_mill(self, source: str, target: str) -&gt; bool:\n        # Check if moving from source to target forms a mill\n\n    def _check_corret_step(self, source: str, target: str) -&gt; bool:\n        # Check if move is to an adjacent position\n\n    def _count_player_pieces(self, color: str) -&gt; int:\n        # Count total pieces for a player (hand + board)\n\n    def _execute_move(self, source: str, target: str, remove: str) -&gt; None:\n        # Execute a validated move\n\n    def _show_state(self, move: Optional[str] = None) -&gt; None:\n        # Display current board state\n\n    def determine_winner(self) -&gt; Optional[LaskerPlayer]:\n        # Determine winner based on game state\n\n    def _get_move_with_timeout(self) -&gt; Optional[str]:\n        # Get a move from the current player with timeout\n\n    def run_game(self) -&gt; Optional[LaskerPlayer]:\n        # Main game loop\n\n    def _cleanup_game(self) -&gt; None:\n        # Clean up resources when game ends\n</code></pre>"},{"location":"api/games/laskermorris/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Description Default <code>player1_command</code> <code>str</code> Command to run the first player Required <code>player2_command</code> <code>str</code> Command to run the second player Required <code>visual</code> <code>bool</code> Enable web visualization <code>True</code> <code>select_rand</code> <code>bool</code> Randomize player colors <code>True</code> <code>timeout</code> <code>int</code> Timeout in seconds for each move <code>5</code> <code>debug</code> <code>bool</code> Enable debug output <code>False</code> <code>logging</code> <code>bool</code> Enable detailed logging <code>False</code> <code>port</code> <code>int</code> Port for web visualization <code>8000</code> <code>print_board</code> <code>bool</code> Print board to console after moves <code>False</code>"},{"location":"api/games/laskermorris/#attributes","title":"Attributes","text":"Attribute Type Description <code>move_timeout</code> <code>float</code> Timeout for each player's move <code>game_history</code> <code>List[Dict]</code> History of game moves and states <code>board_states</code> <code>List[Dict]</code> History of board states <code>hand_states</code> <code>List[Dict]</code> History of hand states <code>debug</code> <code>bool</code> Whether debug mode is enabled <code>port</code> <code>int</code> Port for web visualization <code>prin_board</code> <code>bool</code> Whether to print board after moves <code>moves_without_taking</code> <code>int</code> Counter for moves without captures <code>board</code> <code>Dict[str, Optional[str]]</code> Current board state <code>player_hands</code> <code>Dict[str, int]</code> Number of pieces in each player's hand <code>invalid_fields</code> <code>Set[str]</code> Set of invalid board positions <code>visual</code> <code>bool</code> Whether visualization is enabled <code>web</code> <code>Optional[LaskerMorrisWeb]</code> Web interface instance"},{"location":"api/games/laskermorris/#key-method-details","title":"Key Method Details","text":""},{"location":"api/games/laskermorris/#initialize_game","title":"initialize_game()","text":"<p>Sets up the initial game state, including:</p> <ul> <li>Creating an empty board</li> <li>Starting player processes</li> <li>Starting the web server (if visualization is enabled)</li> <li>Notifying players of their colors</li> </ul> <p>Return type: <code>None</code></p>"},{"location":"api/games/laskermorris/#make_movemove","title":"make_move(move)","text":"<p>Processes a player's move, validating and executing it if valid.</p> <p>Parameters:</p> <ul> <li><code>move</code> (str): The move in format \"source target remove\"</li> </ul> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the move was valid and executed</li> <li><code>False</code> if the move was invalid</li> </ul>"},{"location":"api/games/laskermorris/#_is_valid_movesource-target-remove","title":"_is_valid_move(source, target, remove)","text":"<p>Performs comprehensive validation of a move against game rules.</p> <p>Parameters:</p> <ul> <li><code>source</code> (str): Source position or hand (\"h1\"/\"h2\")</li> <li><code>target</code> (str): Target position</li> <li><code>remove</code> (str): Position to remove or \"r0\" for no capture</li> </ul> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the move is valid</li> <li><code>False</code> if any rule is violated</li> </ul>"},{"location":"api/games/laskermorris/#_is_millsource-target","title":"_is_mill(source, target)","text":"<p>Checks if moving from source to target would form a mill.</p> <p>Parameters:</p> <ul> <li><code>source</code> (str): Source position or hand</li> <li><code>target</code> (str): Target position</li> </ul> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the move forms a mill</li> <li><code>False</code> otherwise</li> </ul>"},{"location":"api/games/laskermorris/#_count_player_piecescolor","title":"_count_player_pieces(color)","text":"<p>Counts the total number of pieces a player has (hand + board).</p> <p>Parameters:</p> <ul> <li><code>color</code> (str): The player's color (\"blue\" or \"orange\")</li> </ul> <p>Return type: <code>int</code></p> <ul> <li>Total number of pieces</li> </ul>"},{"location":"api/games/laskermorris/#determine_winner","title":"determine_winner()","text":"<p>Determines if there is a winner based on current game state.</p> <p>Return type: <code>Optional[LaskerPlayer]</code></p> <ul> <li>The winning player if there is one</li> <li><code>None</code> if the game is a draw or not yet over</li> </ul>"},{"location":"api/games/laskermorris/#run_game","title":"run_game()","text":"<p>Main game loop that runs until a player wins or the game ends in a draw.</p> <p>Return type: <code>Optional[LaskerPlayer]</code></p> <ul> <li>The winning player if there is one</li> <li><code>None</code> if the game ended in a draw</li> </ul>"},{"location":"api/games/laskermorris/#game-rules-implementation","title":"Game Rules Implementation","text":""},{"location":"api/games/laskermorris/#board-layout","title":"Board Layout","text":"<p>The board is represented as a dictionary where:</p> <ul> <li>Keys are positions in the format <code>&lt;column&gt;&lt;row&gt;</code> (e.g., \"a1\", \"d3\", \"g7\")</li> <li>Values are player colors (\"blue\", \"orange\") or <code>None</code> for empty positions</li> </ul> <p>Invalid positions are stored in the <code>invalid_fields</code> set:</p> <pre><code>self.invalid_fields = {\n    \"a2\", \"a3\", \"a5\", \"a6\", \"b1\", \"b3\", \"b5\", \"b7\", \"c1\", \"c2\", \"c6\", \"c7\",\n    \"d4\", \"e1\", \"e2\", \"e6\", \"e7\", \"f1\", \"f3\", \"f5\", \"f7\", \"g2\", \"g3\", \"g5\", \"g6\",\n}\n</code></pre>"},{"location":"api/games/laskermorris/#player-hands","title":"Player Hands","text":"<p>Each player starts with 10 pieces in their hand, tracked in the <code>player_hands</code> dictionary:</p> <pre><code>self.player_hands = {\"blue\": 10, \"orange\": 10}\n</code></pre>"},{"location":"api/games/laskermorris/#mill-detection","title":"Mill Detection","text":"<p>Mills are detected by checking if three pieces of the same color are in a line:</p> <pre><code>mills = [\n    # Horizontal mills\n    [\"a1\", \"a4\", \"a7\"], [\"b2\", \"b4\", \"b6\"], [\"c3\", \"c4\", \"c5\"],\n    [\"d1\", \"d2\", \"d3\"], [\"d5\", \"d6\", \"d7\"], [\"e3\", \"e4\", \"e5\"],\n    [\"f2\", \"f4\", \"f6\"], [\"g1\", \"g4\", \"g7\"],\n    # Vertical mills\n    [\"a1\", \"d1\", \"g1\"], [\"b2\", \"d2\", \"f2\"], [\"c3\", \"d3\", \"e3\"],\n    [\"a4\", \"b4\", \"c4\"], [\"e4\", \"f4\", \"g4\"], [\"c5\", \"d5\", \"e5\"],\n    [\"b6\", \"d6\", \"f6\"], [\"a7\", \"d7\", \"g7\"],\n]\n</code></pre>"},{"location":"api/games/laskermorris/#movement-rules","title":"Movement Rules","text":"<p>Movement is restricted to adjacent positions, defined in a neighbors dictionary:</p> <pre><code>neighbors = {\n    \"a1\": [\"a4\", \"d1\"], \"a4\": [\"a1\", \"a7\", \"b4\"], \"a7\": [\"a4\", \"d7\"],\n    # ... (more positions)\n}\n</code></pre> <p>When a player has exactly 3 pieces, they can \"fly\" to any empty position (not just adjacent ones).</p>"},{"location":"api/games/laskermorris/#capture-rules","title":"Capture Rules","text":"<p>When a player forms a mill, they can capture an opponent's piece with these restrictions:</p> <ul> <li>Cannot capture a piece that is part of a mill unless no other pieces are available</li> <li>Must capture after forming a mill</li> </ul>"},{"location":"api/games/laskermorris/#game-end-conditions","title":"Game End Conditions","text":"<p>The game ends when:</p> <ul> <li>A player has fewer than 3 pieces (loss)</li> <li>Players make 20 moves without any captures (draw)</li> <li>A player has no valid moves available (loss)</li> </ul>"},{"location":"api/games/laskermorris/#usage-example","title":"Usage Example","text":"<p>Here's how to create and run a Lasker Morris game:</p> <pre><code># Create a LaskerMorris game instance\ngame = LaskerMorris(\n    player1_command=\"python player1.py\",\n    player2_command=\"python player2.py\",\n    visual=True,\n    select_rand=True,\n    timeout=5,\n    debug=True,\n    logging=True,\n    port=8000,\n    print_board=True\n)\n\n# Run the game and get the winner\nwinner = game.run_game()\n\n# Handle the game result\nif winner:\n    print(f\"Winner: {winner.get_color()}\")\nelse:\n    print(\"Game ended in a draw\")\n\n# Clean up resources\ngame._cleanup_game()\n</code></pre>"},{"location":"api/games/laskermorris/#game-flow","title":"Game Flow","text":"<p>The typical game flow is:</p> <ol> <li>Initialize the board and player processes</li> <li>Notify players of their colors</li> <li>First player makes a move</li> <li>Validate the move against game rules</li> <li>Execute the move and update the game state</li> <li>Check for win or draw conditions</li> <li>Send the move to the second player</li> <li>Repeat steps 3-7, alternating players, until the game ends</li> <li>Return the winner or <code>None</code> for a draw</li> </ol>"},{"location":"api/games/laskermorris/#error-handling","title":"Error Handling","text":"<p>The <code>LaskerMorris</code> class includes robust error handling for:</p> <ul> <li>Invalid move formats</li> <li>Moves to invalid or occupied positions</li> <li>Mill and capture rule violations</li> <li>Movement rule violations</li> <li>Player timeouts</li> <li>Process communication errors</li> </ul>"},{"location":"api/games/laskermorris/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>The game includes a comprehensive move validation system</li> <li>Mill detection and verification is thorough to ensure rule compliance</li> <li>An oscillation detection system prevents endless games</li> <li>The adjacent movement rule is enforced when a player has more than 3 pieces</li> <li>The visualization shows the board, player hands, and move history</li> </ul>"},{"location":"api/games/tictactoe/","title":"TicTacToe","text":"<p>The <code>TicTacToe</code> class provides a complete implementation of the Tic-tac-toe game for the CS4341 Game Referee system. This class extends <code>AbstractGame</code> and manages the game state, rules, player interaction, and win condition detection.</p>"},{"location":"api/games/tictactoe/#class-definition","title":"Class Definition","text":"<pre><code>class TicTacToe(AbstractGame):\n    VALID_COLUMNS = set(\"abc\")\n    VALID_ROWS = set(\"123\")\n\n    def __init__(\n        self,\n        player1_command: str,\n        player2_command: str,\n        visual: bool = True,\n        random_assignment: bool = False,\n        move_timeout: int = 5,\n        enable_logging: bool = False,\n        debug: bool = False,\n        port: int = GameConfig.DEFAULT_WEB_PORT,\n    ):\n        # Initialize game with players and settings\n\n    def _create_web_interface(self):\n        from .web import TicTacToeWeb\n        return TicTacToeWeb(self)\n\n    def initialize_game(self) -&gt; None:\n        # Set up initial game state\n\n    def _validate_move_format(self, move: str) -&gt; Tuple[bool, Optional[str]]:\n        # Validate move format (e.g., \"a1\", \"b2\")\n\n    def make_move(self, move: str) -&gt; bool:\n        # Process and execute a player's move\n\n    def _show_state(self, last_move: Optional[str] = None) -&gt; None:\n        # Display current board state (for debugging)\n\n    def _check_winner(self) -&gt; Optional[str]:\n        # Check for win conditions\n\n    def _is_board_full(self) -&gt; bool:\n        # Check if the board is full (draw condition)\n\n    def determine_winner(self) -&gt; Optional[TicTacToePlayer]:\n        # Determine the winner based on game state\n\n    def _get_move_with_timeout(self) -&gt; Optional[str]:\n        # Get a move from the current player with timeout handling\n\n    def run_game(self) -&gt; Optional[TicTacToePlayer]:\n        # Main game loop\n\n    def _cleanup_game(self) -&gt; None:\n        # Clean up resources when game ends\n</code></pre>"},{"location":"api/games/tictactoe/#constructor-parameters","title":"Constructor Parameters","text":"Parameter Type Description Default <code>player1_command</code> <code>str</code> Command to run the first player Required <code>player2_command</code> <code>str</code> Command to run the second player Required <code>visual</code> <code>bool</code> Enable web visualization <code>True</code> <code>random_assignment</code> <code>bool</code> Randomize player symbols (X/O) <code>False</code> <code>move_timeout</code> <code>int</code> Timeout in seconds for each move <code>5</code> <code>enable_logging</code> <code>bool</code> Enable detailed logging <code>False</code> <code>debug</code> <code>bool</code> Enable debug output <code>False</code> <code>port</code> <code>int</code> Port for web visualization <code>8000</code>"},{"location":"api/games/tictactoe/#attributes","title":"Attributes","text":"Attribute Type Description <code>move_timeout</code> <code>int</code> Timeout for each player's move <code>debug</code> <code>bool</code> Whether debug mode is enabled <code>enable_logging</code> <code>bool</code> Whether logging is enabled <code>port</code> <code>int</code> Port for web visualization <code>board</code> <code>Dict[str, Optional[str]]</code> Current board state <code>visual</code> <code>bool</code> Whether visualization is enabled <code>web</code> <code>Optional[TicTacToeWeb]</code> Web interface instance <code>move_history</code> <code>List[str]</code> History of moves made"},{"location":"api/games/tictactoe/#method-details","title":"Method Details","text":""},{"location":"api/games/tictactoe/#initialize_game","title":"initialize_game()","text":"<p>Sets up the initial game state, including:</p> <ul> <li>Creating an empty 3x3 board</li> <li>Starting player processes</li> <li>Starting the web server (if visualization is enabled)</li> <li>Notifying players of their symbols</li> </ul> <p>Return type: <code>None</code></p>"},{"location":"api/games/tictactoe/#_validate_move_formatmove","title":"_validate_move_format(move)","text":"<p>Validates that a move is in the correct format.</p> <p>Parameters:</p> <ul> <li><code>move</code> (str): The move to validate (e.g., \"a1\", \"b3\")</li> </ul> <p>Return type: <code>Tuple[bool, Optional[str]]</code></p> <ul> <li>First element: <code>True</code> if valid, <code>False</code> if invalid</li> <li>Second element: Error message if invalid, <code>None</code> if valid</li> </ul>"},{"location":"api/games/tictactoe/#make_movemove","title":"make_move(move)","text":"<p>Processes a player's move, updating the game state if valid.</p> <p>Parameters:</p> <ul> <li><code>move</code> (str): The move to make (e.g., \"a1\", \"b3\")</li> </ul> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the move was valid and executed</li> <li><code>False</code> if the move was invalid</li> </ul>"},{"location":"api/games/tictactoe/#_check_winner","title":"_check_winner()","text":"<p>Checks all possible win combinations to determine if a player has won.</p> <p>Return type: <code>Optional[str]</code></p> <ul> <li>The symbol of the winning player if there is a winner</li> <li><code>None</code> if there is no winner</li> </ul>"},{"location":"api/games/tictactoe/#_is_board_full","title":"_is_board_full()","text":"<p>Checks if the board is completely filled (draw condition).</p> <p>Return type: <code>bool</code></p> <ul> <li><code>True</code> if the board is full</li> <li><code>False</code> if there are still empty positions</li> </ul>"},{"location":"api/games/tictactoe/#determine_winner","title":"determine_winner()","text":"<p>Determines if there is a winner based on the current board state.</p> <p>Return type: <code>Optional[TicTacToePlayer]</code></p> <ul> <li>The winning player if there is one</li> <li><code>None</code> if the game is a draw or not yet over</li> </ul>"},{"location":"api/games/tictactoe/#_get_move_with_timeout","title":"_get_move_with_timeout()","text":"<p>Gets a move from the current player with timeout handling.</p> <p>Return type: <code>Optional[str]</code></p> <ul> <li>The player's move if received within the timeout</li> <li><code>None</code> if the player timed out</li> </ul>"},{"location":"api/games/tictactoe/#run_game","title":"run_game()","text":"<p>Main game loop that runs until the game ends.</p> <p>Return type: <code>Optional[TicTacToePlayer]</code></p> <ul> <li>The winning player if there is one</li> <li><code>None</code> if the game ended in a draw</li> </ul>"},{"location":"api/games/tictactoe/#usage-example","title":"Usage Example","text":"<p>Here's how to create and run a Tic-tac-toe game:</p> <pre><code># Create a TicTacToe game instance\ngame = TicTacToe(\n    player1_command=\"python player1.py\",\n    player2_command=\"python player2.py\",\n    visual=True,\n    random_assignment=True,\n    move_timeout=5,\n    enable_logging=True,\n    debug=True,\n    port=8000\n)\n\n# Run the game and get the winner\nwinner = game.run_game()\n\n# Handle the game result\nif winner:\n    print(f\"Winner: {winner.get_symbol()}\")\nelse:\n    print(\"Game ended in a draw\")\n\n# Clean up resources\ngame._cleanup_game()\n</code></pre>"},{"location":"api/games/tictactoe/#board-representation","title":"Board Representation","text":"<p>The Tic-tac-toe board is represented as a dictionary where:</p> <ul> <li>Keys are positions in the format <code>&lt;column&gt;&lt;row&gt;</code> (e.g., \"a1\", \"b2\", \"c3\")</li> <li>Values are player symbols (\"BLUE\" for X, \"ORANGE\" for O) or <code>None</code> for empty positions</li> </ul> <pre><code>{\n    \"a1\": None, \"b1\": \"BLUE\", \"c1\": None,\n    \"a2\": None, \"b2\": \"ORANGE\", \"c2\": None,\n    \"a3\": \"BLUE\", \"b3\": None, \"c3\": \"ORANGE\"\n}\n</code></pre>"},{"location":"api/games/tictactoe/#win-conditions","title":"Win Conditions","text":"<p>The game checks for these win combinations:</p> <p>Rows:</p> <ul> <li>\"a1\", \"b1\", \"c1\"</li> <li>\"a2\", \"b2\", \"c2\"</li> <li>\"a3\", \"b3\", \"c3\"</li> </ul> <p>Columns:</p> <ul> <li>\"a1\", \"a2\", \"a3\"</li> <li>\"b1\", \"b2\", \"b3\"</li> <li>\"c1\", \"c2\", \"c3\"</li> </ul> <p>Diagonals:</p> <ul> <li>\"a1\", \"b2\", \"c3\"</li> <li>\"a3\", \"b2\", \"c1\"</li> </ul>"},{"location":"api/games/tictactoe/#game-flow","title":"Game Flow","text":"<p>The typical game flow is:</p> <ol> <li>Initialize the game board and player processes</li> <li>Notify players of their symbols</li> <li>First player makes a move</li> <li>Validate the move and update the board</li> <li>Check for win or draw conditions</li> <li>Send the move to the second player</li> <li>Repeat steps 3-6, alternating players, until the game ends</li> <li>Return the winner or <code>None</code> for a draw</li> </ol>"},{"location":"api/games/tictactoe/#error-handling","title":"Error Handling","text":"<p>The <code>TicTacToe</code> class includes robust error handling for:</p> <ul> <li>Invalid move formats</li> <li>Moves to occupied positions</li> <li>Player timeouts</li> <li>Game state inconsistencies</li> <li>Process communication errors</li> </ul>"},{"location":"api/games/tictactoe/#implementation-notes","title":"Implementation Notes","text":"<ul> <li>The game uses <code>ThreadPoolExecutor</code> for timeout handling</li> <li>Player processes communicate via standard input/output</li> <li>The game maintains a move history for analysis and visualization</li> <li>Debug mode provides console output of the current board state</li> <li>The web visualization shows the current state and move history</li> </ul>"},{"location":"development/adding-games/","title":"Adding New Games","text":"<p>This guide walks through the process of adding a new game to the CS4341 Game Referee system. We'll use a hypothetical game called \"Connect4\" as an example.</p>"},{"location":"development/adding-games/#step-1-create-game-player-class","title":"Step 1: Create Game Player Class","text":"<p>First, define a player class for your game in <code>src/core/players.py</code>:</p> <pre><code>class Connect4Player(AbstractPlayer):\n    \"\"\"Player implementation for Connect4 game.\"\"\"\n\n    def __init__(self, command: str, color: str, log: bool = False, debug: bool = False):\n        super().__init__(command, log, debug)\n        self.color = color  # \"red\" or \"yellow\"\n\n    def get_color(self) -&gt; str:\n        return self.color\n\n    def is_red(self) -&gt; bool:\n        return self.color == \"red\"\n\n    def is_yellow(self) -&gt; bool:\n        return self.color == \"yellow\"\n</code></pre>"},{"location":"development/adding-games/#step-2-create-game-configuration","title":"Step 2: Create Game Configuration","text":"<p>Add configuration for your game in <code>src/config.py</code>:</p> <pre><code>@dataclass(frozen=True)\nclass Connect4Config(GameConfig):\n    BOARD_WIDTH: Final[int] = 7\n    BOARD_HEIGHT: Final[int] = 6\n    DEFAULT_RANDOM_ASSIGNMENT: Final[bool] = True\n</code></pre>"},{"location":"development/adding-games/#step-3-implement-game-logic","title":"Step 3: Implement Game Logic","text":"<p>Create the main game class in <code>src/core/games.py</code>:</p> <pre><code>class Connect4(AbstractGame):\n    \"\"\"Implementation of Connect4 game.\"\"\"\n\n    def __init__(\n        self,\n        player1_command: str,\n        player2_command: str,\n        visual: bool = True,\n        select_rand: bool = True,\n        timeout: int = 5,\n        debug: bool = False,\n        logging: bool = False,\n        port: int = 8000,\n    ):\n        # Initialize game settings\n        self.move_timeout = timeout + 0.5\n        self.debug = debug\n        self.port = port\n        self.board = [[None for _ in range(Connect4Config.BOARD_WIDTH)]\n                     for _ in range(Connect4Config.BOARD_HEIGHT)]\n        self.moves_history = []\n\n        # Initialize players with randomly assigned colors\n        colors = [\"red\", \"yellow\"]\n        if select_rand:\n            random.shuffle(colors)\n\n        player1 = Connect4Player(player1_command, colors[0], logging, debug)\n        player2 = Connect4Player(player2_command, colors[1], logging, debug)\n        super().__init__(player1, player2)\n\n        # Initialize visualization\n        self.visual = visual\n        self.web = self._create_web_interface() if visual else None\n\n    def _create_web_interface(self):\n        from .web import Connect4Web\n        return Connect4Web(self)\n\n    def initialize_game(self) -&gt; None:\n        \"\"\"Initialize the game state.\"\"\"\n        # Start player processes\n        self._player1.start()\n        self._player2.start()\n\n        # Start web server if visualization enabled\n        if self.visual and self.web:\n            self.web.start_web_server(self.port)\n\n        # Send initial color information to players\n        self._player1.write(self._player1.get_color())\n        self._player2.write(self._player2.get_color())\n\n    def make_move(self, move: str) -&gt; bool:\n        \"\"\"Process a player's move.\"\"\"\n        try:\n            # Validate column number (0-6)\n            column = int(move.strip())\n            if column &lt; 0 or column &gt;= Connect4Config.BOARD_WIDTH:\n                return False\n\n            # Find the first empty spot in the column (bottom to top)\n            for row in range(Connect4Config.BOARD_HEIGHT - 1, -1, -1):\n                if self.board[row][column] is None:\n                    # Place the piece\n                    self.board[row][column] = self.current_player.get_color()\n                    self.moves_history.append((column, row))\n                    return True\n\n            # Column is full\n            return False\n\n        except ValueError:\n            # Not a valid integer\n            return False\n\n    def _check_winner(self) -&gt; Optional[str]:\n        \"\"\"Check if there's a winner.\"\"\"\n        # Check horizontal, vertical, and diagonal win conditions\n        # (implementation details omitted for brevity)\n        pass\n\n    def _is_board_full(self) -&gt; bool:\n        \"\"\"Check if the board is completely full.\"\"\"\n        return all(cell is not None for row in self.board for cell in row)\n\n    def determine_winner(self) -&gt; Optional[Connect4Player]:\n        \"\"\"Determine if there's a winner or draw.\"\"\"\n        winning_color = self._check_winner()\n        if winning_color:\n            self._is_game_over = True\n            return (\n                self._player1 if self._player1.get_color() == winning_color\n                else self._player2\n            )\n\n        if self._is_board_full():\n            self._is_game_over = True\n            return None\n\n        return None\n\n    def _get_move_with_timeout(self) -&gt; Optional[str]:\n        \"\"\"Get a move from the current player with timeout.\"\"\"\n        with ThreadPoolExecutor(max_workers=1) as executor:\n            try:\n                future = executor.submit(self.current_player.read)\n                return future.result(timeout=self.move_timeout)\n            except TimeoutError:\n                return None\n\n    def run_game(self) -&gt; Optional[Connect4Player]:\n        \"\"\"Run the main game loop.\"\"\"\n        while not self.is_game_over:\n            # Get move from current player\n            move = self._get_move_with_timeout()\n\n            # Handle timeout or invalid move\n            if move is None or not self.make_move(move):\n                self._is_game_over = True\n                winner = self._player2 if self.current_player == self._player1 else self._player1\n                return winner\n\n            # Send move to other player\n            other_player = self._player2 if self.current_player == self._player1 else self._player1\n            other_player.write(move)\n\n            # Check for winner\n            winner = self.determine_winner()\n            if winner is not None:\n                return winner\n            elif self._is_board_full():\n                return None\n\n            self.switch_player()\n\n        return None\n</code></pre>"},{"location":"development/adding-games/#step-4-implement-web-interface","title":"Step 4: Implement Web Interface","text":"<p>Create a web interface in <code>src/core/web.py</code>:</p> <pre><code>class Connect4Web(WebGame):\n    \"\"\"Web interface for Connect4 game.\"\"\"\n\n    def __init__(self, game):\n        super().__init__(GameConfig.WEB_TEMPLATE_FOLDER)\n        self.game = game\n        self.game_history = []\n        self.end_message = None\n\n    def get_game_state_json(self):\n        \"\"\"Return current game state as JSON.\"\"\"\n        game_data = {\n            \"board\": self.game.board,\n            \"currentPlayer\": self.game.current_player.get_color(),\n            \"isGameOver\": self.game.is_game_over,\n            \"history\": self.game.moves_history,\n            \"endMessage\": self.end_message if self.game.is_game_over else None,\n        }\n        return jsonify(game_data)\n\n    def get_index(self):\n        \"\"\"Render template with game state data.\"\"\"\n        game_data = {\n            \"board\": self.game.board,\n            \"currentPlayer\": self.game.current_player.get_color(),\n            \"isGameOver\": self.game.is_game_over,\n            \"history\": self.game.moves_history,\n            \"endMessage\": self.end_message if self.game.is_game_over else None,\n        }\n        return render_template(\"./connect4/index.html\", game_data=game_data)\n</code></pre>"},{"location":"development/adding-games/#step-5-create-html-template","title":"Step 5: Create HTML Template","text":"<p>Create a template in <code>src/web/connect4/index.html</code> for visualization:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Connect4 Game&lt;/title&gt;\n    &lt;style&gt;\n      /* CSS styles for Connect4 board */\n      body {\n        font-family:\n          system-ui,\n          -apple-system,\n          sans-serif;\n        background: #f8fafc;\n        color: #475569;\n        padding: 2rem;\n      }\n      .board {\n        display: grid;\n        grid-template-columns: repeat(7, 50px);\n        grid-template-rows: repeat(6, 50px);\n        gap: 5px;\n        background: #2563eb;\n        padding: 10px;\n        border-radius: 10px;\n      }\n      .cell {\n        width: 50px;\n        height: 50px;\n        background: white;\n        border-radius: 50%;\n      }\n      .red {\n        background: #ef4444;\n      }\n      .yellow {\n        background: #eab308;\n      }\n      /* Additional styles omitted for brevity */\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=\"container\"&gt;\n      &lt;header&gt;\n        &lt;h1&gt;Connect4&lt;/h1&gt;\n        &lt;p&gt;Part of the CS4341 Referee Implementation&lt;/p&gt;\n      &lt;/header&gt;\n\n      &lt;div class=\"game-container\"&gt;\n        &lt;div class=\"board\" id=\"board\"&gt;\n          &lt;!-- Board will be populated by JavaScript --&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"controls\"&gt;\n          &lt;div class=\"status\" id=\"currentPlayer\"&gt;\n            Current Player: &lt;span id=\"player\"&gt;&lt;/span&gt;\n          &lt;/div&gt;\n          &lt;!-- Additional controls --&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      // JavaScript for the Connect4 board and game logic\n      let gameState = {{ game_data|tojson|safe }};\n\n      function updateBoard() {\n          const board = document.getElementById('board');\n          board.innerHTML = '';\n\n          for (let row = 0; row &lt; gameState.board.length; row++) {\n              for (let col = 0; col &lt; gameState.board[row].length; col++) {\n                  const cell = document.createElement('div');\n                  cell.className = 'cell';\n\n                  if (gameState.board[row][col] === 'red') {\n                      cell.classList.add('red');\n                  } else if (gameState.board[row][col] === 'yellow') {\n                      cell.classList.add('yellow');\n                  }\n\n                  board.appendChild(cell);\n              }\n          }\n      }\n\n      async function fetchGameState() {\n          try {\n              const response = await fetch('/game-state');\n              const data = await response.json();\n              gameState = data;\n              updateBoard();\n          } catch (error) {\n              console.error('Error fetching game state:', error);\n          }\n      }\n\n      updateBoard();\n      setInterval(fetchGameState, 1000);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"development/adding-games/#step-6-add-cli-command","title":"Step 6: Add CLI Command","text":"<p>Add a CLI command in <code>src/cli/commands.py</code>:</p> <pre><code>@click.command(name=\"connect4\")\n@click.option(\"--player1\", \"-p1\", prompt=\"Enter Player 1 command\", help=\"Command to run Player 1.\")\n@click.option(\"--player2\", \"-p2\", prompt=\"Enter Player 2 command\", help=\"Command to run Player 2.\")\n@click.option(\"--visual/--no-visual\", \"-v/-nv\", default=Connect4Config.DEFAULT_VISUALIZATION,\n              help=\"Enable/disable game visualization\")\n@click.option(\"--random-assignment/--no-random-assignment\", \"-r/-nr\",\n              default=Connect4Config.DEFAULT_RANDOM_ASSIGNMENT, help=\"Enable/disable random selection of first player\")\n@click.option(\"--timeout\", \"-t\", type=int, default=Connect4Config.DEFAULT_TIMEOUT,\n              help=\"Timeout in seconds for each player's move\")\n@click.option(\"--port\", type=int, default=GameConfig.DEFAULT_WEB_PORT,\n              help=\"Port for visualization webserver\")\n@click.option(\"--log/--no-log\", \"-l/-nl\", default=Connect4Config.DEFAULT_LOGGING,\n              help=\"Enable/disable logging\")\n@click.option(\"--debug/--no-debug\", \"-d/-nd\", default=Connect4Config.DEFAULT_DEBUG,\n              help=\"Enable/disable debug output\")\ndef start_connect4(player1, player2, visual, random_assignment, timeout, port, log, debug):\n    \"\"\"\ud83c\udfae Start a new game of Connect4!\"\"\"\n    try:\n        game = Connect4(\n            player1_command=player1,\n            player2_command=player2,\n            visual=visual,\n            select_rand=random_assignment,\n            timeout=timeout,\n            debug=debug,\n            logging=log,\n            port=port\n        )\n        winner = game.run_game()\n        _handle_game_result(winner, visual, game)\n\n    except Exception as e:\n        click.echo(f\"\\n{Fore.RED}Error: {e}{Style.RESET_ALL}\")\n        raise click.Abort()\n</code></pre>"},{"location":"development/adding-games/#step-7-register-cli-command","title":"Step 7: Register CLI Command","text":"<p>Register your command in <code>src/cli/parser.py</code>:</p> <pre><code>def create_cli() -&gt; click.Group:\n    \"\"\"Create the main CLI group with all commands\"\"\"\n    @click.group()\n    @click.version_option(\"1.1.1\")\n    def cli():\n        pass\n\n    cli.add_command(start_game)      # Lasker Morris\n    cli.add_command(start_tictactoe)\n    cli.add_command(start_connect4)  # Add your new command here\n\n    return cli\n</code></pre>"},{"location":"development/adding-games/#step-8-update-imports","title":"Step 8: Update Imports","text":"<p>Add the necessary imports in <code>src/core/__init__.py</code>:</p> <pre><code>from .abstract import AbstractGame, AbstractPlayer, WebGame\nfrom .games import LaskerMorris, TicTacToe, Connect4\nfrom .players import LaskerPlayer, TicTacToePlayer, Connect4Player\nfrom .utils import BoardUtils, GameError, GameLogger, InvalidMoveError, TimeoutError\nfrom .web import LaskerMorrisWeb, TicTacToeWeb, Connect4Web\n\n__all__ = [\n    \"AbstractGame\", \"AbstractPlayer\", \"WebGame\",\n    \"LaskerPlayer\", \"TicTacToePlayer\", \"Connect4Player\",\n    \"LaskerMorris\", \"TicTacToe\", \"Connect4\",\n    \"LaskerMorrisWeb\", \"TicTacToeWeb\", \"Connect4Web\",\n    \"GameError\", \"InvalidMoveError\", \"TimeoutError\",\n    \"GameLogger\", \"BoardUtils\"\n]\n</code></pre>"},{"location":"development/adding-games/#step-9-create-tests","title":"Step 9: Create Tests","text":"<p>Create tests in <code>tests/game/test_connect4.py</code>:</p> <pre><code>import unittest\nfrom unittest.mock import Mock, patch\n\nfrom src.core.games import Connect4\n\nclass TestConnect4(unittest.TestCase):\n    @patch(\"subprocess.Popen\")\n    def setUp(self, mock_popen) -&gt; None:\n        \"\"\"Set up test environment before each test.\"\"\"\n        # Mock subprocess.Popen\n        mock_process = Mock()\n        mock_process.stdout.readline.return_value = b\"3\\n\"  # Middle column\n        mock_process.poll.return_value = None\n        mock_popen.return_value = mock_process\n\n        with patch(\"random.shuffle\") as mock_shuffle:\n            # Ensure consistent color assignment for tests\n            mock_shuffle.side_effect = lambda x: x\n            self.game = Connect4(\"player1\", \"player2\", visual=False)\n\n        # Mock the players after initialization\n        self.game._player1 = Mock()\n        self.game._player2 = Mock()\n        self.game._player1.get_color.return_value = \"red\"\n        self.game._player2.get_color.return_value = \"yellow\"\n        self.game._current_player = self.game._player1\n\n    def test_initialization(self) -&gt; None:\n        \"\"\"Test game initialization.\"\"\"\n        self.assertEqual(len(self.game.board), 6)  # 6 rows\n        self.assertEqual(len(self.game.board[0]), 7)  # 7 columns\n        self.assertEqual(self.game.current_player.get_color(), \"red\")\n\n    def test_make_move(self) -&gt; None:\n        \"\"\"Test making valid and invalid moves.\"\"\"\n        # Valid move in middle column\n        self.assertTrue(self.game.make_move(\"3\"))\n        self.assertEqual(self.game.board[5][3], \"red\")  # Bottom row, middle column\n\n        # Test more cases...\n\n    # Additional test methods...\n</code></pre>"},{"location":"development/adding-games/#step-10-document-the-new-game","title":"Step 10: Document the New Game","text":"<p>Create documentation in <code>docs/games/connect4.md</code>:</p> <pre><code># Connect4\n\nConnect4 is a two-player connection game where players take turns dropping colored discs into a vertically suspended grid. The objective is to connect four of one's own discs of the same color consecutively vertically, horizontally, or diagonally before the opponent.\n\n## Rules\n\n- Players take turns dropping their colored discs into a 7\u00d76 grid\n- The pieces fall straight down, occupying the lowest available position in the column\n- The first player to connect four of their discs horizontally, vertically, or diagonally wins\n- The game is a draw if the grid fills completely without a winner\n\n## Player Communication\n\n### Game Start\n\n- First player receives: `\"red\"`\n- Second player receives: `\"yellow\"`\n\n### Move Format\n</code></pre> <p> Example: \"3\" (center column, 0-indexed) <pre><code>## Running Connect4\n\n```bash\ncs4341-referee connect4 -p1 \"python player1.py\" -p2 \"python player2.py\" --visual\n</code></pre>"},{"location":"development/adding-games/#python-player-template","title":"Python Player Template","text":"<pre><code>import sys\n\ndef main():\n    # Read initial color\n    color = input().strip()  # \"red\" or \"yellow\"\n\n    while True:\n        try:\n            # Read opponent's move or game start\n            game_input = input().strip()\n\n            # If this is the first move and you're the first player,\n            # game_input will be empty\n\n            # Your move logic here: choose column 0-6\n            # For example, always choose the middle column:\n            move = \"3\"\n\n            # Send move to referee\n            print(move, flush=True)\n\n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"development/adding-games/#strategy-tips","title":"Strategy Tips","text":"<ol> <li>Center control: The center column provides the most connection opportunities</li> <li>Blocking: Prevent your opponent from forming connections</li> <li>Two threats: Create positions where you have two potential winning moves</li> <li>Look ahead: Plan several moves ahead to create winning opportunities</li> </ol> <pre><code>## Key Implementation Details\n\nWhen implementing a new game, focus on these key aspects:\n\n1. **Game rules**: Ensure all game rules are correctly enforced\n2. **Player communication**: Define clear protocols for player input/output\n3. **Error handling**: Properly handle timeouts, invalid moves, and other issues\n4. **Visualization**: Create an intuitive web interface for game monitoring\n5. **Testing**: Write comprehensive tests for your game implementation\n\nBy following this template, you can add any turn-based board game to the referee system.\n</code></pre>"},{"location":"development/architecture/","title":"Architecture","text":"<p>The CS4341 Game Referee system follows a modular and extensible architecture that allows for easy addition of new games and features. This document provides an overview of the core architectural components and how they interact.</p>"},{"location":"development/architecture/#core-components","title":"Core Components","text":""},{"location":"development/architecture/#abstract-base-classes","title":"Abstract Base Classes","text":"<p>The system is built around three key abstract base classes:</p>"},{"location":"development/architecture/#abstractplayer","title":"AbstractPlayer","text":"<p>The <code>AbstractPlayer</code> class manages communication with external player processes:</p> <pre><code>class AbstractPlayer(ABC):\n    def __init__(self, command: str, log: bool = False, debug: bool = False):\n        # Initialize player process information\n\n    def start(self) -&gt; None:\n        # Start the player process\n\n    def write(self, data: str) -&gt; None:\n        # Write data to the player process\n\n    def read(self) -&gt; str:\n        # Read data from the player process\n\n    def stop(self) -&gt; None:\n        # Terminate the player process\n</code></pre> <p>This class handles:</p> <ul> <li>Starting and stopping external player processes</li> <li>Reading and writing to player processes via stdin/stdout</li> <li>Error handling for process communication</li> </ul>"},{"location":"development/architecture/#abstractgame","title":"AbstractGame","text":"<p>The <code>AbstractGame</code> class defines the core interface for all game implementations:</p> <pre><code>class AbstractGame(ABC):\n    def __init__(self, player1: AbstractPlayer, player2: AbstractPlayer) -&gt; None:\n        # Initialize game state\n\n    @property\n    def current_player(self) -&gt; AbstractPlayer:\n        # Return the current player\n\n    def switch_player(self) -&gt; None:\n        # Switch to the other player\n\n    @property\n    def is_game_over(self) -&gt; bool:\n        # Check if game is over\n\n    @abstractmethod\n    def initialize_game(self) -&gt; None:\n        # Initialize game state\n\n    @abstractmethod\n    def make_move(self, move: Any) -&gt; bool:\n        # Process a move and update game state\n\n    @abstractmethod\n    def determine_winner(self) -&gt; Optional[AbstractPlayer]:\n        # Determine if there's a winner\n</code></pre> <p>This class handles:</p> <ul> <li>Managing the game state</li> <li>Tracking the current player</li> <li>Determining when a game is over</li> <li>Defining the interface for specific game implementations</li> </ul>"},{"location":"development/architecture/#webgame","title":"WebGame","text":"<p>The <code>WebGame</code> class provides web visualization capabilities:</p> <pre><code>class WebGame(ABC):\n    def __init__(self, template_folder):\n        # Initialize web server\n\n    @abstractmethod\n    def get_game_state_json(self):\n        # Return game state as JSON\n\n    @abstractmethod\n    def get_index(self):\n        # Render web interface\n\n    def start_web_server(self, port=8000):\n        # Start the web server\n</code></pre> <p>This class handles:</p> <ul> <li>Setting up a Flask web server</li> <li>Providing endpoints for game state and visualization</li> <li>Rendering HTML templates for game display</li> </ul>"},{"location":"development/architecture/#game-implementations","title":"Game Implementations","text":"<p>Each specific game implementation extends the abstract classes:</p>"},{"location":"development/architecture/#game-class","title":"Game Class","text":"<p>Game classes like <code>TicTacToe</code> and <code>LaskerMorris</code> extend <code>AbstractGame</code>:</p> <pre><code>class TicTacToe(AbstractGame):\n    def __init__(self, player1_command: str, player2_command: str, ...):\n        # Initialize game-specific state\n\n    def initialize_game(self) -&gt; None:\n        # Set up board and start players\n\n    def make_move(self, move: str) -&gt; bool:\n        # Validate and execute move\n\n    def determine_winner(self) -&gt; Optional[TicTacToePlayer]:\n        # Check for winning conditions\n</code></pre>"},{"location":"development/architecture/#player-class","title":"Player Class","text":"<p>Game-specific player classes extend <code>AbstractPlayer</code>:</p> <pre><code>class TicTacToePlayer(AbstractPlayer):\n    def __init__(self, command: str, symbol: str, log: bool = False):\n        super().__init__(command, log)\n        self.symbol = symbol\n\n    def get_symbol(self) -&gt; str:\n        return self.symbol\n</code></pre>"},{"location":"development/architecture/#web-interface-class","title":"Web Interface Class","text":"<p>Game-specific web interfaces extend <code>WebGame</code>:</p> <pre><code>class TicTacToeWeb(WebGame):\n    def __init__(self, game):\n        super().__init__(GameConfig.WEB_TEMPLATE_FOLDER)\n        self.game = game\n\n    def get_game_state_json(self):\n        # Convert game state to JSON\n\n    def get_index(self):\n        # Render game template\n</code></pre>"},{"location":"development/architecture/#command-line-interface","title":"Command Line Interface","text":"<p>The CLI layer provides a user-friendly interface to access the game functionality:</p> <pre><code>@click.command(name=\"tictactoe\")\n@click.option(\"--player\", \"-p\", ...)\ndef start_tictactoe(player, player2, ...):\n    # Create and run TicTacToe game\n</code></pre>"},{"location":"development/architecture/#communication-flow","title":"Communication Flow","text":"<p>The typical flow of communication in the system is:</p> <ol> <li>User starts a game via CLI</li> <li>CLI creates game instance with player commands</li> <li>Game initializes and starts player processes</li> <li>Game sends initial state to players</li> <li>Players respond with moves</li> <li>Game validates moves and updates state</li> <li>Web interface displays current state</li> <li>Game determines when the match is over</li> </ol>"},{"location":"development/architecture/#extension-points","title":"Extension Points","text":"<p>The system is designed to be easily extended at several points:</p> <ol> <li>New games: Create new classes that implement <code>AbstractGame</code></li> <li>New player types: Create new classes that extend <code>AbstractPlayer</code></li> <li>Enhanced visualization: Extend <code>WebGame</code> for custom visualizations</li> <li>Additional CLI commands: Add new commands to the CLI module</li> </ol> <p>This modular approach allows for adding new functionality without modifying the core system components.</p>"},{"location":"development/visualization/","title":"Web Visualization","text":"<p>The CS4341 Game Referee system includes a powerful web-based visualization component that provides real-time insight into game states, move history, and results. This document explains how the visualization system works and how to extend it for new games.</p>"},{"location":"development/visualization/#overview","title":"Overview","text":"<p>The visualization system consists of:</p> <ol> <li>Server-Side: Flask application serving game state and HTML templates</li> <li>Client-Side: HTML, CSS, and JavaScript for rendering the game</li> <li>Communication: JSON API for real-time state updates</li> </ol>"},{"location":"development/visualization/#architecture","title":"Architecture","text":"<p>The visualization is built on these core components:</p> <ul> <li>WebGame: Abstract base class for web interfaces</li> <li>Game-Specific Web Classes: Implementations for each game (e.g., TicTacToeWeb)</li> <li>HTML Templates: Game-specific templates in the <code>web/</code> directory</li> <li>JSON API: Endpoint for retrieving current game state</li> <li>Waitress Server: Production WSGI server for hosting the web interface</li> </ul>"},{"location":"development/visualization/#how-it-works","title":"How It Works","text":"<p>When a game is run with the <code>--visual</code> flag:</p> <ol> <li>The game creates a web interface instance (<code>WebGame</code> subclass)</li> <li>A Flask app is initialized with the game's template folder</li> <li>The web server starts in a separate thread</li> <li>Two main routes are defined:</li> <li><code>/</code>: Renders the HTML template</li> <li><code>/game-state</code>: Returns the current game state as JSON</li> <li>The client-side JavaScript polls for game state updates</li> <li>The visualization updates in real-time as the game progresses</li> </ol>"},{"location":"development/visualization/#webgame-class","title":"WebGame Class","text":"<p>The <code>WebGame</code> abstract base class provides the foundation for web visualization:</p> <pre><code>class WebGame(ABC):\n    \"\"\"Abstract base class for web-enabled games\"\"\"\n\n    def __init__(self, template_folder):\n        from flask import Flask\n        from flask_cors import CORS\n\n        self.app = Flask(__name__, template_folder=template_folder)\n        CORS(self.app)\n        self.game_history = []\n        self.app.route(\"/\")(self.get_index)\n        self.app.route(\"/game-state\")(self.get_game_state_json)\n\n    @abstractmethod\n    def get_game_state_json(self):\n        pass\n\n    @abstractmethod\n    def get_index(self):\n        pass\n\n    def start_web_server(self, port=8000):\n        import threading\n        from click import echo\n        from waitress import serve\n\n        url = f\"http://localhost:{port}\"\n        echo(f\"\\n\ud83c\udfae Game visualization available at: \ud83c\udf10 {url}\")\n        threading.Thread(\n            target=lambda: serve(self.app, host=\"0.0.0.0\", port=port), daemon=True\n        ).start()\n</code></pre>"},{"location":"development/visualization/#html-templates","title":"HTML Templates","text":"<p>Each game requires an HTML template in the <code>src/web/{game_name}/index.html</code> directory. The template receives game state data via Jinja2 templating.</p> <p>A typical template includes:</p> <ol> <li>HTML Structure: Board layout and game controls</li> <li>CSS Styling: Visual appearance of the game elements</li> <li>JavaScript Functions:</li> <li>Initial state rendering</li> <li>State update logic</li> <li>API polling</li> <li>User interaction (if needed)</li> </ol>"},{"location":"development/visualization/#game-state-json-format","title":"Game State JSON Format","text":"<p>The game state is provided as JSON with a structure similar to:</p> <pre><code>{\n  \"board\": {\n    /* board state */\n  },\n  \"currentPlayer\": \"blue\",\n  \"isGameOver\": false,\n  \"history\": {\n    \"moves\": [\n      /* move history */\n    ],\n    \"boards\": [\n      /* board history */\n    ]\n  },\n  \"endMessage\": null\n}\n</code></pre> <p>Each game can customize this structure to include game-specific data.</p>"},{"location":"development/visualization/#adding-visualization-for-a-new-game","title":"Adding Visualization for a New Game","text":"<p>Follow these steps to add visualization for a new game:</p>"},{"location":"development/visualization/#1-create-a-web-interface-class","title":"1. Create a Web Interface Class","text":"<p>Create a game-specific web class that inherits from <code>WebGame</code>:</p> <pre><code>class Connect4Web(WebGame):\n    def __init__(self, game):\n        super().__init__(GameConfig.WEB_TEMPLATE_FOLDER)\n        self.game = game\n        self.end_message = None\n\n    def get_game_state_json(self):\n        \"\"\"Return current game state as JSON\"\"\"\n        game_data = {\n            \"board\": self.game.board,\n            \"currentPlayer\": self.game.current_player.get_color(),\n            \"isGameOver\": self.game.is_game_over,\n            \"history\": self.game.moves_history,\n            \"endMessage\": self.end_message if self.game.is_game_over else None,\n        }\n        return jsonify(game_data)\n\n    def get_index(self):\n        \"\"\"Render template with game state data\"\"\"\n        game_data = {\n            \"board\": self.game.board,\n            \"currentPlayer\": self.game.current_player.get_color(),\n            \"isGameOver\": self.game.is_game_over,\n            \"history\": self.game.moves_history,\n            \"endMessage\": self.end_message if self.game.is_game_over else None,\n        }\n        return render_template(\"./connect4/index.html\", game_data=game_data)\n</code></pre>"},{"location":"development/visualization/#2-create-an-html-template","title":"2. Create an HTML Template","text":"<p>Create a template in <code>src/web/{game_name}/index.html</code>:</p> <pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\"&gt;\n  &lt;head&gt;\n    &lt;meta charset=\"UTF-8\" /&gt;\n    &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\" /&gt;\n    &lt;title&gt;Game Name&lt;/title&gt;\n    &lt;style&gt;\n      /* CSS styles for your game */\n      body {\n        font-family:\n          system-ui,\n          -apple-system,\n          sans-serif;\n        background: #f8fafc;\n        color: #475569;\n        padding: 2rem;\n      }\n      .board {\n        /* Board styles */\n      }\n      /* Additional styles */\n    &lt;/style&gt;\n  &lt;/head&gt;\n  &lt;body&gt;\n    &lt;div class=\"container\"&gt;\n      &lt;header&gt;\n        &lt;h1&gt;Game Name&lt;/h1&gt;\n      &lt;/header&gt;\n\n      &lt;div class=\"game-container\"&gt;\n        &lt;div class=\"board\" id=\"board\"&gt;\n          &lt;!-- Board will be populated by JavaScript --&gt;\n        &lt;/div&gt;\n\n        &lt;div class=\"controls\"&gt;\n          &lt;div class=\"status\" id=\"currentPlayer\"&gt;\n            Current Player: &lt;span id=\"player\"&gt;&lt;/span&gt;\n          &lt;/div&gt;\n          &lt;!-- Additional controls --&gt;\n        &lt;/div&gt;\n      &lt;/div&gt;\n    &lt;/div&gt;\n\n    &lt;script&gt;\n      // Initial game state from server\n      let gameState = {{ game_data|tojson|safe }};\n\n      function updateBoard() {\n          // Update the visual representation of the board\n          const board = document.getElementById('board');\n          board.innerHTML = '';\n\n          // Board rendering logic\n          // ...\n\n          // Update player information\n          document.getElementById('player').textContent = gameState.currentPlayer;\n      }\n\n      async function fetchGameState() {\n          try {\n              const response = await fetch('/game-state');\n              const data = await response.json();\n              gameState = data;\n              updateBoard();\n          } catch (error) {\n              console.error('Error fetching game state:', error);\n          }\n      }\n\n      // Initial board update and polling setup\n      updateBoard();\n      setInterval(fetchGameState, 1000);\n    &lt;/script&gt;\n  &lt;/body&gt;\n&lt;/html&gt;\n</code></pre>"},{"location":"development/visualization/#3-update-game-class","title":"3. Update Game Class","text":"<p>In your game implementation, add a method to create the web interface:</p> <pre><code>def _create_web_interface(self):\n    from .web import Connect4Web\n    return Connect4Web(self)\n</code></pre> <p>And in the <code>initialize_game</code> method, start the web server:</p> <pre><code>def initialize_game(self) -&gt; None:\n    # Initialize board\n    # Start player processes\n    # ...\n\n    # Start web server if visualization enabled\n    if self.visual and self.web:\n        self.web.start_web_server(self.port)\n</code></pre>"},{"location":"development/visualization/#4-update-core-imports","title":"4. Update Core Imports","text":"<p>Add your web class to the imports in <code>src/core/__init__.py</code>:</p> <pre><code>from .web import LaskerMorrisWeb, TicTacToeWeb, Connect4Web\n\n__all__ = [\n    # ...\n    \"LaskerMorrisWeb\", \"TicTacToeWeb\", \"Connect4Web\",\n    # ...\n]\n</code></pre>"},{"location":"development/visualization/#best-practices","title":"Best Practices","text":""},{"location":"development/visualization/#performance","title":"Performance","text":"<ul> <li>Keep DOM manipulations minimal</li> <li>Use efficient selectors for DOM updates</li> <li>Consider using SVG for game boards</li> <li>Optimize JSON payload size for fast updates</li> </ul>"},{"location":"development/visualization/#user-experience","title":"User Experience","text":"<ul> <li>Use clear visual cues for game state</li> <li>Highlight the current player</li> <li>Animate transitions when possible</li> <li>Include move history and navigation</li> <li>Display clear win/loss/draw messages</li> </ul>"},{"location":"development/visualization/#responsive-design","title":"Responsive Design","text":"<ul> <li>Design for both desktop and mobile</li> <li>Use flexible layouts with CSS Grid or Flexbox</li> <li>Test on different screen sizes</li> <li>Ensure text is readable on all devices</li> </ul>"},{"location":"development/visualization/#accessibility","title":"Accessibility","text":"<ul> <li>Use semantic HTML elements</li> <li>Include alt text for visual elements</li> <li>Ensure sufficient color contrast</li> <li>Support keyboard navigation where applicable</li> </ul>"},{"location":"development/visualization/#advanced-visualization-features","title":"Advanced Visualization Features","text":"<p>Consider these advanced features for your game visualizations:</p>"},{"location":"development/visualization/#move-animation","title":"Move Animation","text":"<p>Animate pieces moving between positions for better visual clarity:</p> <pre><code>function animateMove(source, target) {\n  const piece = document.getElementById(`piece-${source}`);\n  const sourcePos = getPositionCoordinates(source);\n  const targetPos = getPositionCoordinates(target);\n\n  piece.style.transition = \"transform 0.5s ease-in-out\";\n  piece.style.transform = `translate(${targetPos.x - sourcePos.x}px, ${targetPos.y - sourcePos.y}px)`;\n\n  setTimeout(() =&gt; {\n    // Update actual board after animation\n    updateBoard();\n  }, 500);\n}\n</code></pre>"},{"location":"development/visualization/#game-replay","title":"Game Replay","text":"<p>Add controls to replay the entire game:</p> <pre><code>function replayGame() {\n  let moveIndex = 0;\n  const interval = setInterval(() =&gt; {\n    if (moveIndex &gt;= gameState.history.moves.length) {\n      clearInterval(interval);\n      return;\n    }\n\n    updateBoard(gameState.history.boards[moveIndex]);\n    moveIndex++;\n  }, 1000);\n}\n</code></pre>"},{"location":"development/visualization/#game-statistics","title":"Game Statistics","text":"<p>Display statistics about the game:</p> <pre><code>function updateStatistics() {\n  document.getElementById(\"move-count\").textContent =\n    gameState.history.moves.length;\n  document.getElementById(\"blue-captures\").textContent = countCaptures(\"blue\");\n  document.getElementById(\"orange-captures\").textContent =\n    countCaptures(\"orange\");\n  document.getElementById(\"game-time\").textContent = formatGameTime();\n}\n</code></pre> <p>By following these guidelines, you can create rich, interactive visualizations for your games that enhance the understanding and enjoyment of the CS4341 Game Referee system.</p>"},{"location":"games/laskermorris/","title":"Lasker Morris","text":"<p>Lasker Morris is a variant of the classic Nine Men's Morris board game, developed by Emanuel Lasker. It features special movement rules and strategic complexity that make it an excellent challenge for AI development.</p>"},{"location":"games/laskermorris/#game-rules","title":"Game Rules","text":""},{"location":"games/laskermorris/#board-layout","title":"Board Layout","text":"<p>The Lasker Morris board consists of 24 valid positions arranged in three concentric squares connected by lines:</p> <pre><code>7   a   b   c   d   e   f   g\n  +---+---+---+---+---+---+---+\n7 | a7|   |   | d7|   |   | g7| 7\n  +   +   +   +   +   +   +   +\n6 |   | b6|   | d6|   | f6|   | 6\n  +   +   +   +   +   +   +   +\n5 |   |   | c5| d5| e5|   |   | 5\n  +   +   +   +   +   +   +   +\n4 | a4| b4| c4|   | e4| f4| g4| 4\n  +   +   +   +   +   +   +   +\n3 |   |   | c3| d3| e3|   |   | 3\n  +   +   +   +   +   +   +   +\n2 |   | b2|   | d2|   | f2|   | 2\n  +   +   +   +   +   +   +   +\n1 | a1|   |   | d1|   |   | g1| 1\n  +---+---+---+---+---+---+---+\n    a   b   c   d   e   f   g\n</code></pre> <p>The empty spaces are invalid positions where pieces cannot be placed.</p>"},{"location":"games/laskermorris/#game-phases","title":"Game Phases","text":"<p>Lasker Morris has three main phases:</p> <ol> <li>Placement Phase: Players take turns placing pieces from their hand onto empty board positions</li> <li>Movement Phase: After all pieces are placed, players move pieces to adjacent positions</li> <li>Flying Phase: When a player has only 3 pieces left, they can \"fly\" to any empty position</li> </ol>"},{"location":"games/laskermorris/#basic-rules","title":"Basic Rules","text":"<ul> <li>Players start with 10 pieces each (blue and orange)</li> <li>During the placement phase, players place one piece per turn</li> <li>During the movement phase, pieces can only move to adjacent empty positions along the lines</li> <li>When a player has exactly 3 pieces, they can move to any empty position on the board</li> <li>Forming a \"mill\" (three pieces in a straight line) allows capturing an opponent's piece</li> <li>A player loses when reduced to fewer than 3 pieces</li> <li>The game ends in a draw if the same position repeats 3 times or after 20 moves without captures</li> </ul>"},{"location":"games/laskermorris/#running-a-game","title":"Running a Game","text":"<p>To run a Lasker Morris game:</p> <pre><code>cs4341-referee laskermorris -p1 \"python player1.py\" -p2 \"python player2.py\" --visual\n</code></pre>"},{"location":"games/laskermorris/#player-communication","title":"Player Communication","text":""},{"location":"games/laskermorris/#initialization","title":"Initialization","text":"<p>At the start of the game, each player receives their color:</p> <ul> <li>First player receives: <code>\"blue\"</code></li> <li>Second player receives: <code>\"orange\"</code></li> </ul>"},{"location":"games/laskermorris/#move-format","title":"Move Format","text":"<p>Moves in Lasker Morris follow this format:</p> <pre><code>&lt;source&gt; &lt;target&gt; &lt;remove&gt;\n</code></pre> <p>Where:</p> <ul> <li><code>&lt;source&gt;</code>: The source position (e.g., \"d1\") or \"h1\"/\"h2\" if placing from hand</li> <li><code>&lt;target&gt;</code>: The target position (must be empty)</li> <li><code>&lt;remove&gt;</code>: A position to remove an opponent's piece (\"r0\" if no capture)</li> </ul> <p>Examples:</p> <ul> <li><code>h1 d1 r0</code>: Place a piece from hand to position d1, no capture</li> <li><code>d1 d2 e3</code>: Move piece from d1 to d2 and capture opponent's piece at e3</li> <li><code>a1 g7 r0</code>: Flying move from a1 to g7 (only valid with exactly 3 pieces)</li> </ul>"},{"location":"games/laskermorris/#game-flow","title":"Game Flow","text":"<ol> <li>The referee starts both player processes</li> <li>Each player is notified of their color</li> <li>Players take turns making moves:</li> <li>The current player sends a valid move</li> <li>The referee validates and executes the move</li> <li>The opponent receives the move made</li> <li>The game continues until someone wins or a draw occurs</li> <li>The referee sends \"END\" to both players when the game is over</li> </ol>"},{"location":"games/laskermorris/#player-implementation","title":"Player Implementation","text":"<p>Here's a basic template for implementing a Lasker Morris player:</p> <pre><code>import sys\n\ndef main():\n    # Read initial color\n    color = input().strip()  # \"blue\" or \"orange\"\n\n    # Track pieces in hand\n    pieces_in_hand = 10\n\n    # Track board state\n    board = {}  # position -&gt; color mapping\n\n    while True:\n        try:\n            # Read opponent's move or game start\n            game_input = input().strip()\n\n            # Check if game has ended\n            if game_input == \"END\":\n                break\n\n            # Process opponent's move if not the first move\n            if game_input:\n                source, target, remove = game_input.split()\n                # Update internal board state\n                # ...\n\n            # Determine move (simplified example)\n            move = \"\"\n            if pieces_in_hand &gt; 0:\n                # Placement phase - place from hand\n                move = \"h1 d1 r0\"  # Example: place at center\n                pieces_in_hand -= 1\n            else:\n                # Movement phase\n                # Implement movement logic\n                # ...\n\n            # Send move to referee\n            print(move, flush=True)\n\n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"games/laskermorris/#web-visualization","title":"Web Visualization","text":"<p>When run with the <code>--visual</code> flag, the referee provides a web-based visualization:</p> <p></p>"},{"location":"games/laskermorris/#mill-combinations","title":"Mill Combinations","text":"<p>A key aspect of Lasker Morris is forming and recognizing mills. Here are all possible mill combinations:</p> <p>Horizontal Mills:</p> <ul> <li>a1, a4, a7</li> <li>b2, b4, b6</li> <li>c3, c4, c5</li> <li>d1, d2, d3</li> <li>d5, d6, d7</li> <li>e3, e4, e5</li> <li>f2, f4, f6</li> <li>g1, g4, g7</li> </ul> <p>Vertical Mills:</p> <ul> <li>a1, d1, g1</li> <li>b2, d2, f2</li> <li>c3, d3, e3</li> <li>a4, b4, c4</li> <li>e4, f4, g4</li> <li>c5, d5, e5</li> <li>b6, d6, f6</li> <li>a7, d7, g7</li> </ul>"},{"location":"games/laskermorris/#strategic-elements","title":"Strategic Elements","text":""},{"location":"games/laskermorris/#placement-phase","title":"Placement Phase","text":"<ol> <li>Control the Intersections: Positions like d3, d5, b4, and f4 are at the intersection of multiple potential mills</li> <li>Block Opponent Mills: Place pieces to prevent your opponent from forming mills</li> <li>Create Mill Setups: Position pieces to enable multiple potential mills in future turns</li> </ol>"},{"location":"games/laskermorris/#movement-phase","title":"Movement Phase","text":"<ol> <li>Mill Creation: Move pieces to form mills and capture opponent pieces</li> <li>Defend Against Capture: Protect pieces that are part of formed mills</li> <li>Double Mills: Create configurations where moving one piece forms two mills simultaneously</li> <li>Block Opponent Movement: Position pieces to restrict opponent movement options</li> </ol>"},{"location":"games/laskermorris/#flying-phase","title":"Flying Phase","text":"<ol> <li>Aggressive Flying: When reduced to 3 pieces, use flying to create unexpected mills</li> <li>Defensive Flying: Use flying to quickly respond to threats and avoid capture</li> </ol>"},{"location":"games/laskermorris/#advanced-topics","title":"Advanced Topics","text":""},{"location":"games/laskermorris/#board-evaluation","title":"Board Evaluation","text":"<p>A strong Lasker Morris AI needs an effective evaluation function. Consider these factors:</p> <ul> <li>Piece count difference</li> <li>Number of potential mills</li> <li>Mobility (number of possible moves)</li> <li>Control of strategic positions</li> <li>Number of pieces in potential mills</li> </ul>"},{"location":"games/laskermorris/#mill-detection-function","title":"Mill Detection Function","text":"<p>Here's a function to detect if a position is part of a mill:</p> <pre><code>def is_mill(board, position, color):\n    mills = [\n        # Horizontal mills\n        [\"a1\", \"a4\", \"a7\"], [\"b2\", \"b4\", \"b6\"], [\"c3\", \"c4\", \"c5\"],\n        [\"d1\", \"d2\", \"d3\"], [\"d5\", \"d6\", \"d7\"], [\"e3\", \"e4\", \"e5\"],\n        [\"f2\", \"f4\", \"f6\"], [\"g1\", \"g4\", \"g7\"],\n        # Vertical mills\n        [\"a1\", \"d1\", \"g1\"], [\"b2\", \"d2\", \"f2\"], [\"c3\", \"d3\", \"e3\"],\n        [\"a4\", \"b4\", \"c4\"], [\"e4\", \"f4\", \"g4\"], [\"c5\", \"d5\", \"e5\"],\n        [\"b6\", \"d6\", \"f6\"], [\"a7\", \"d7\", \"g7\"],\n    ]\n\n    for mill in mills:\n        if position in mill and all(board.get(pos) == color for pos in mill):\n            return True\n    return False\n</code></pre>"},{"location":"games/laskermorris/#neighbor-mapping","title":"Neighbor Mapping","text":"<p>For efficient move generation, maintain a map of adjacent positions:</p> <pre><code>neighbors = {\n    \"a1\": [\"a4\", \"d1\"], \"a4\": [\"a1\", \"a7\", \"b4\"], \"a7\": [\"a4\", \"d7\"],\n    \"b2\": [\"b4\", \"d2\"], \"b4\": [\"b2\", \"b6\", \"a4\", \"c4\"], \"b6\": [\"b4\", \"d6\"],\n    \"c3\": [\"c4\", \"d3\"], \"c4\": [\"c3\", \"c5\", \"b4\"], \"c5\": [\"c4\", \"d5\"],\n    \"d1\": [\"a1\", \"d2\", \"g1\"], \"d2\": [\"b2\", \"d1\", \"d3\", \"f2\"],\n    \"d3\": [\"c3\", \"d2\", \"e3\"], \"d5\": [\"c5\", \"d6\", \"e5\"],\n    \"d6\": [\"b6\", \"d5\", \"d7\", \"f6\"], \"d7\": [\"a7\", \"d6\", \"g7\"],\n    \"e3\": [\"d3\", \"e4\"], \"e4\": [\"e3\", \"e5\", \"f4\"], \"e5\": [\"d5\", \"e4\"],\n    \"f2\": [\"d2\", \"f4\"], \"f4\": [\"e4\", \"f2\", \"f6\", \"g4\"], \"f6\": [\"d6\", \"f4\"],\n    \"g1\": [\"d1\", \"g4\"], \"g4\": [\"f4\", \"g1\", \"g7\"], \"g7\": [\"d7\", \"g4\"],\n}\n</code></pre>"},{"location":"games/laskermorris/#testing-strategies","title":"Testing Strategies","text":"<ol> <li>Self-Play: Test your player against itself to identify weaknesses</li> <li>Opening Book: Develop a library of strong opening placements</li> <li>Endgame Tables: Precompute optimal plays for common endgame scenarios</li> <li>Time Management: Make simple, fast decisions in the opening, saving time for critical calculations later</li> </ol> <p>By understanding these concepts, you'll be well-equipped to develop a competitive Lasker Morris AI player!</p>"},{"location":"games/tictactoe/","title":"Tic-tac-toe","text":"<p>Tic-tac-toe is a classic game where two players take turns marking spaces on a 3\u00d73 grid, aiming to place three of their marks in a horizontal, vertical, or diagonal row.</p>"},{"location":"games/tictactoe/#game-rules","title":"Game Rules","text":"<ul> <li>Players take turns placing their symbol (X or O) on an empty cell of the 3\u00d73 grid</li> <li>The first player to form a line of three of their own symbol (horizontally, vertically, or diagonally) wins</li> <li>If all cells are filled and no player has formed a line, the game ends in a draw</li> </ul>"},{"location":"games/tictactoe/#board-representation","title":"Board Representation","text":"<p>The Tic-tac-toe board is represented as a 3\u00d73 grid with positions labeled as follows:</p> <pre><code>    a   b   c\n  +---+---+---+\n3 | a3| b3| c3|  3\n  +---+---+---+\n2 | a2| b2| c2|  2\n  +---+---+---+\n1 | a1| b1| c1|  1\n  +---+---+---+\n    a   b   c\n</code></pre> <ul> <li>Columns are labeled as 'a', 'b', and 'c'</li> <li>Rows are labeled as '1', '2', and '3'</li> <li>Each position is referenced by its column followed by its row (e.g., 'b2' for the center position)</li> </ul>"},{"location":"games/tictactoe/#running-a-game","title":"Running a Game","text":"<p>To run a Tic-tac-toe game:</p> <pre><code>cs4341-referee tictactoe -p \"python your_player.py\" --visual\n</code></pre> <p>This will run a game where your player plays against itself. To specify a different opponent:</p> <pre><code>cs4341-referee tictactoe -p \"python your_player.py\" -p2 \"python opponent_player.py\" --visual\n</code></pre>"},{"location":"games/tictactoe/#player-communication","title":"Player Communication","text":""},{"location":"games/tictactoe/#initialization","title":"Initialization","text":"<p>At the start of the game, each player receives their symbol:</p> <ul> <li>First player receives: <code>\"blue\"</code> (representing X)</li> <li>Second player receives: <code>\"orange\"</code> (representing O)</li> </ul>"},{"location":"games/tictactoe/#move-format","title":"Move Format","text":"<p>The move format for Tic-tac-toe is simply the position where the player wants to place their symbol:</p> <pre><code>&lt;column&gt;&lt;row&gt;\n</code></pre> <p>Examples:</p> <ul> <li><code>a1</code> (bottom-left corner)</li> <li><code>b2</code> (center position)</li> <li><code>c3</code> (top-right corner)</li> </ul>"},{"location":"games/tictactoe/#game-flow","title":"Game Flow","text":"<ol> <li>The referee starts both player processes</li> <li>Each player is notified of their symbol</li> <li>Players take turns making moves:</li> <li>The current player is expected to send a valid move</li> <li>The referee validates the move and updates the game state</li> <li>The opponent receives the move made by the current player</li> <li>The game continues until someone wins or the board is full (draw)</li> </ol>"},{"location":"games/tictactoe/#player-implementation","title":"Player Implementation","text":"<p>Here's a basic template for implementing a Tic-tac-toe player:</p> <pre><code>import sys\n\ndef main():\n    # Read initial symbol (X or O)\n    player_symbol = input().strip()  # Will be \"blue\" or \"orange\"\n\n    # Initialize board (None represents empty cells)\n    board = {f\"{col}{row}\": None for col in \"abc\" for row in \"123\"}\n\n    while True:\n        try:\n            # Read opponent's move or game start\n            game_input = input().strip()\n\n            # Update board with opponent's move (if not first move)\n            if game_input:\n                board[game_input] = \"opponent\"\n\n            # Your move logic here\n            # For example, find the first empty cell:\n            move = next(pos for pos, val in board.items() if val is None)\n\n            # Update our internal board\n            board[move] = \"me\"\n\n            # Send move to referee\n            print(move, flush=True)\n\n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()\n</code></pre>"},{"location":"games/tictactoe/#web-visualization","title":"Web Visualization","text":"<p>When run with the <code>--visual</code> flag, the referee provides a web-based visualization of the game:</p> <p></p> <p>The visualization includes:</p> <ul> <li>Current board state</li> <li>Move history</li> <li>Player information</li> <li>Game status and results</li> </ul>"},{"location":"games/tictactoe/#tips-for-building-a-strong-player","title":"Tips for Building a Strong Player","text":"<ol> <li> <p>Corner Strategy: Starting with corner moves gives more opportunities for creating winning lines</p> </li> <li> <p>Center Control: The center position (b2) provides the most opportunities for creating winning lines</p> </li> <li> <p>Block Opponent: Always check if your opponent is about to win and block them</p> </li> <li> <p>Fork Creation: Create positions where you have two potential winning moves, forcing your opponent to defend one and allowing you to win with the other</p> </li> <li> <p>Minimax Algorithm: Implement the minimax algorithm with alpha-beta pruning for optimal play</p> </li> </ol>"},{"location":"games/tictactoe/#common-mistakes-to-avoid","title":"Common Mistakes to Avoid","text":"<ol> <li> <p>Invalid Move Format: Ensure your move is exactly in the format <code>&lt;column&gt;&lt;row&gt;</code> (e.g., \"b2\")</p> </li> <li> <p>Playing Occupied Cells: Always check that a cell is empty before making a move</p> </li> <li> <p>Slow Response: Make sure your player responds within the timeout period</p> </li> <li> <p>Buffer Flushing: Always use <code>flush=True</code> with print statements to ensure your move is sent immediately</p> </li> <li> <p>Error Handling: Handle EOFError properly to gracefully exit when the game ends</p> </li> </ol>"},{"location":"games/tictactoe/#advanced-topics","title":"Advanced Topics","text":""},{"location":"games/tictactoe/#board-evaluation","title":"Board Evaluation","text":"<p>For AI players, properly evaluating board positions is crucial. A simple evaluation function might assign:</p> <ul> <li>Win: +10</li> <li>Draw: 0</li> <li>Loss: -10</li> </ul> <p>More sophisticated evaluations might consider:</p> <ul> <li>Number of potential winning lines</li> <li>Center control</li> <li>Corner occupation</li> </ul>"},{"location":"games/tictactoe/#minimax-implementation","title":"Minimax Implementation","text":"<p>The minimax algorithm allows your player to find the optimal move by exploring possible future states:</p> <pre><code>def minimax(board, depth, is_maximizing):\n    if is_win(board, \"me\"):\n        return 10 - depth\n    if is_win(board, \"opponent\"):\n        return depth - 10\n    if is_full(board):\n        return 0\n\n    if is_maximizing:\n        best_score = -float('inf')\n        for move in get_empty_cells(board):\n            board[move] = \"me\"\n            score = minimax(board, depth + 1, False)\n            board[move] = None\n            best_score = max(score, best_score)\n        return best_score\n    else:\n        best_score = float('inf')\n        for move in get_empty_cells(board):\n            board[move] = \"opponent\"\n            score = minimax(board, depth + 1, True)\n            board[move] = None\n            best_score = min(score, best_score)\n        return best_score\n</code></pre> <p>With this foundation, you can build a perfect Tic-tac-toe player that never loses!</p>"},{"location":"getting-started/common-options/","title":"Common Options","text":"<p>The CS4341 Game Referee system provides a variety of command-line options to customize game execution. This guide covers the common options available for all games, as well as game-specific options.</p>"},{"location":"getting-started/common-options/#global-options","title":"Global Options","text":"<p>These options work with all supported games:</p> Option Short Description Default <code>--visual / --no-visual</code> <code>-v / -nv</code> Enable/disable web visualization Enabled <code>--random-assignment / --no-random-assignment</code> <code>-r / -nr</code> Randomize player colors/symbols Varies by game <code>--timeout</code> <code>-t</code> Move timeout in seconds 5 <code>--log / --no-log</code> <code>-l / -nl</code> Enable/disable detailed logging Disabled <code>--debug / --no-debug</code> <code>-d / -nd</code> Enable/disable debug output Disabled <code>--port</code> Specify the port for visualization server 8000"},{"location":"getting-started/common-options/#visualization","title":"Visualization","text":"<p>When <code>--visual</code> is enabled (the default), the referee starts a web server to visualize the game:</p> <pre><code>cs4341-referee tictactoe -p \"python player.py\" --visual\n</code></pre> <p>The visualization is available at <code>http://localhost:8000</code> by default. You can customize the port:</p> <pre><code>cs4341-referee tictactoe -p \"python player.py\" --port 8080\n</code></pre>"},{"location":"getting-started/common-options/#timeouts","title":"Timeouts","text":"<p>Use the timeout option to change how long players have to respond with a move:</p> <pre><code>cs4341-referee tictactoe -p \"python player.py\" -t 10  # 10 seconds per move\n</code></pre> <p>If a player doesn't respond within the timeout period, they forfeit their turn or the game (depending on the specific game rules).</p>"},{"location":"getting-started/common-options/#random-assignment","title":"Random Assignment","text":"<p>By default, the referee assigns colors/symbols randomly for fairness in competitive settings. You can disable this to have predictable assignments:</p> <pre><code>cs4341-referee laskermorris -p1 \"python player1.py\" -p2 \"python player2.py\" --no-random-assignment\n</code></pre> <p>With random assignment disabled:</p> <ul> <li>First player gets X in Tic-tac-toe</li> <li>First player gets blue in Lasker Morris</li> </ul>"},{"location":"getting-started/common-options/#logging-and-debugging","title":"Logging and Debugging","text":"<p>Enable logging to record the communication between the referee and players:</p> <pre><code>cs4341-referee tictactoe -p \"python player.py\" --log\n</code></pre> <p>This creates a log file with detailed communication records.</p> <p>For even more information, enable debug mode:</p> <pre><code>cs4341-referee tictactoe -p \"python player.py\" --debug\n</code></pre> <p>In debug mode, the referee prints additional information to the console, including a text representation of the game board after each move.</p>"},{"location":"getting-started/common-options/#game-specific-options","title":"Game-Specific Options","text":""},{"location":"getting-started/common-options/#tic-tac-toe","title":"Tic-tac-toe","text":"Option Short Description <code>--player</code> <code>-p</code> Command to run the player program <code>--player2</code> <code>-p2</code> Command for second player (optional, defaults to same as first player) <p>Example:</p> <pre><code>cs4341-referee tictactoe -p \"python player1.py\" -p2 \"python player2.py\"\n</code></pre> <p>Without <code>-p2</code>, the system uses the same player against itself:</p> <pre><code>cs4341-referee tictactoe -p \"python player.py\"  # Self-play\n</code></pre>"},{"location":"getting-started/common-options/#lasker-morris","title":"Lasker Morris","text":"Option Short Description <code>--player1</code> <code>-p1</code> Command for first player <code>--player2</code> <code>-p2</code> Command for second player <p>Example:</p> <pre><code>cs4341-referee laskermorris -p1 \"python player1.py\" -p2 \"python player2.py\"\n</code></pre> <p>Unlike Tic-tac-toe, Lasker Morris requires specifying both players.</p>"},{"location":"getting-started/common-options/#examples","title":"Examples","text":""},{"location":"getting-started/common-options/#running-a-tournament-match-with-logging","title":"Running a tournament match with logging:","text":"<pre><code>cs4341-referee tictactoe -p \"python team1_player.py\" -p2 \"python team2_player.py\" --log --timeout 3\n</code></pre>"},{"location":"getting-started/common-options/#testing-a-player-against-itself-with-increased-timeout","title":"Testing a player against itself with increased timeout:","text":"<pre><code>cs4341-referee tictactoe -p \"python my_player.py\" -t 10\n</code></pre>"},{"location":"getting-started/common-options/#running-a-headless-game-no-visualization","title":"Running a headless game (no visualization):","text":"<pre><code>cs4341-referee laskermorris -p1 \"python player1.py\" -p2 \"python player2.py\" --no-visual\n</code></pre>"},{"location":"getting-started/common-options/#debugging-a-player-with-fixed-colors","title":"Debugging a player with fixed colors:","text":"<pre><code>cs4341-referee laskermorris -p1 \"python my_player.py\" -p2 \"python opponent.py\" --debug --no-random-assignment\n</code></pre>"},{"location":"getting-started/common-options/#notes","title":"Notes","text":"<ul> <li>Player commands can include arguments, e.g., <code>python player.py --strategy defensive</code></li> <li>For Windows, you might need to use <code>python</code> or <code>py</code> depending on your setup</li> <li>If your player is written in a language other than Python, just provide the appropriate command to run it</li> </ul>"},{"location":"getting-started/installation/","title":"Installation","text":""},{"location":"getting-started/installation/#prerequisites","title":"Prerequisites","text":"<p>Before installing the CS4341 Game Referee, ensure you have the following:</p> <ul> <li>Python 3.10 or higher (Check your Python version)</li> <li>pip package manager (Check pip installation)</li> <li>git (Check git installation)</li> </ul>"},{"location":"getting-started/installation/#installing-from-github","title":"Installing from GitHub","text":"<p>The recommended way to install the referee is directly from GitHub:</p> <pre><code>pip install git+https://github.com/jake-molnia/cs4341-referee.git\n</code></pre> <p>This will install the referee and all its dependencies.</p>"},{"location":"getting-started/installation/#development-installation","title":"Development Installation","text":"<p>If you plan to contribute to the referee or customize it for your own needs, you can install it in development mode:</p> <pre><code># Clone the repository\ngit clone https://github.com/jake-molnia/cs4341-referee.git\ncd cs4341-referee\n\n# Install in development mode with dev dependencies\npip install -e \".[dev]\"\n</code></pre> <p>This installs the package in \"editable\" mode, allowing you to modify the code and see changes immediately without reinstalling.</p>"},{"location":"getting-started/installation/#verifying-installation","title":"Verifying Installation","text":"<p>After installation, verify that the referee is properly installed by checking its version:</p> <pre><code>cs4341-referee --version\n</code></pre> <p>You should see output showing the current version of the referee.</p>"},{"location":"getting-started/installation/#dependencies","title":"Dependencies","text":"<p>The referee has the following dependencies:</p> <ul> <li>click: Command-line interface toolkit</li> <li>colorama: Terminal color output</li> <li>flask: Web server for visualization</li> <li>flask-cors: Cross-origin resource sharing support</li> <li>waitress: Production WSGI server</li> <li>toml: Configuration file parsing</li> </ul> <p>For development:</p> <ul> <li>pytest: Testing framework</li> <li>pytest-cov: Test coverage</li> <li>black: Code formatting</li> <li>isort: Import sorting</li> <li>mypy: Type checking</li> <li>pre-commit: Git hooks</li> </ul>"},{"location":"getting-started/installation/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter any issues during installation:</p>"},{"location":"getting-started/installation/#common-issues","title":"Common Issues","text":"<ol> <li> <p>Python version error:    Make sure you have Python 3.10 or higher installed. Check with <code>python --version</code> or <code>python3 --version</code>.</p> </li> <li> <p>Permission errors:    You might need to use <code>pip install --user</code> or consider using a virtual environment.</p> </li> <li> <p>Missing dependencies:    If you see errors about missing packages, try running:</p> </li> </ol> <pre><code>pip install --upgrade pip\npip install git+https://github.com/jake-molnia/cs4341-referee.git\n</code></pre> <ol> <li>Command not found:    Ensure that the Python scripts directory is in your PATH. You might need to restart your terminal after installation.</li> </ol> <p>If issues persist, check the project's GitHub issues or contact the course staff for assistance.</p>"},{"location":"getting-started/quick-start/","title":"Quick Start","text":"<p>This guide will help you quickly get started with the CS4341 Game Referee system. We'll walk through installing the referee, running your first game, and providing a basic player implementation.</p>"},{"location":"getting-started/quick-start/#basic-installation","title":"Basic Installation","text":"<p>Install the referee directly from GitHub:</p> <pre><code>pip install git+https://github.com/jake-molnia/cs4341-referee.git\n</code></pre>"},{"location":"getting-started/quick-start/#running-your-first-tic-tac-toe-game","title":"Running Your First Tic-tac-toe Game","text":"<p>Let's create a simple player that makes random moves and use it to run a Tic-tac-toe game:</p> <ol> <li>Create a file called <code>random_player.py</code>:</li> </ol> <pre><code>import sys\nimport random\n\ndef main():\n    # Read initial symbol (X or O)\n    player_symbol = input().strip()\n    print(f\"I am player {player_symbol}\", file=sys.stderr)\n\n    # Start with an empty board\n    board = {f\"{col}{row}\": None for col in \"abc\" for row in \"123\"}\n\n    while True:\n        try:\n            # Read opponent's move or game start\n            game_input = input().strip()\n\n            # If this isn't the first move, update the board with opponent's move\n            if game_input:\n                col, row = game_input[0], game_input[1]\n                board[game_input] = \"opponent\"\n                print(f\"Opponent moved: {game_input}\", file=sys.stderr)\n\n            # Find all empty positions\n            empty_positions = [pos for pos, value in board.items() if value is None]\n\n            # Choose a random empty position\n            if empty_positions:\n                move = random.choice(empty_positions)\n                # Update our internal board\n                board[move] = \"me\"\n                # Send the move to the referee\n                print(move, flush=True)\n                print(f\"I moved: {move}\", file=sys.stderr)\n\n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ol> <li>Run a game with two instances of your random player:</li> </ol> <pre><code>cs4341-referee tictactoe -p \"python random_player.py\" --visual\n</code></pre> <p>This will open a web browser with a visualization of the game. You'll see the two players making random moves until one wins or the game ends in a draw.</p>"},{"location":"getting-started/quick-start/#running-a-lasker-morris-game","title":"Running a Lasker Morris Game","text":"<p>Let's run a Lasker Morris game with the same random player strategy:</p> <ol> <li>Create a file called <code>random_lasker_player.py</code>:</li> </ol> <pre><code>import sys\nimport random\n\ndef main():\n    # Read initial color (blue or orange)\n    color = input().strip()\n    print(f\"I am the {color} player\", file=sys.stderr)\n\n    # Track pieces in hand\n    pieces_in_hand = 10\n\n    # Track board state (simplified)\n    board = {}\n\n    while True:\n        try:\n            # Read opponent's move or game start\n            game_input = input().strip()\n\n            # If this isn't the first move and not the end game message\n            if game_input and game_input != \"END\":\n                print(f\"Opponent moved: {game_input}\", file=sys.stderr)\n                # Parse opponent's move\n                parts = game_input.split()\n                # Update our board state based on opponent's move\n                # (Implementation simplified for this example)\n\n            # Generate a move\n            if pieces_in_hand &gt; 0:\n                # If we have pieces in hand, place one\n                # Choose a random valid position (avoiding invalid fields)\n                valid_positions = ['a1', 'a4', 'a7', 'b2', 'b4', 'b6', 'c3',\n                                  'c4', 'c5', 'd1', 'd2', 'd3', 'd5', 'd6',\n                                  'd7', 'e3', 'e4', 'e5', 'f2', 'f4', 'f6',\n                                  'g1', 'g4', 'g7']\n\n                # Filter out occupied positions\n                valid_positions = [pos for pos in valid_positions if pos not in board]\n\n                target = random.choice(valid_positions)\n                move = f\"h1 {target} r0\"  # h1 for hand, r0 for no capture\n                pieces_in_hand -= 1\n            else:\n                # For simplicity, we'll just make a random move\n                # In a real player, you'd implement proper movement rules\n                move = \"h1 d1 r0\"  # Placeholder move\n\n            # Send the move to the referee\n            print(move, flush=True)\n            print(f\"I moved: {move}\", file=sys.stderr)\n\n        except EOFError:\n            break\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <ol> <li>Run a Lasker Morris game:</li> </ol> <pre><code>cs4341-referee laskermorris -p1 \"python random_lasker_player.py\" -p2 \"python random_lasker_player.py\" --visual\n</code></pre>"},{"location":"getting-started/quick-start/#next-steps","title":"Next Steps","text":"<p>Now that you've run your first games, you can:</p> <ol> <li>Improve your player implementations with actual game strategy</li> <li>Explore the referee system's features and options</li> <li>Set up a tournament to test your AI against others</li> </ol> <p>Check out the Common Options guide to learn about the various configuration options available for running games.</p>"},{"location":"tournament/configuration/","title":"Tournament Configuration","text":"<p>The CS4341 Tournament Runner uses a TOML configuration file to define tournament settings, games, and participants. This guide explains the configuration options and provides examples for setting up different tournament types.</p>"},{"location":"tournament/configuration/#configuration-file-structure","title":"Configuration File Structure","text":"<p>The tournament configuration file (<code>tournament.toml</code>) has the following main sections:</p> <ol> <li>Game Settings: Defines which game to use and its settings</li> <li>Group Definitions: Optional predefined groups</li> <li>Agent Definitions: Players participating in the tournament</li> </ol> <p>Here's a basic structure:</p> <pre><code># Game type and settings\ngame = \"tictactoe\"\n\n[settings]\ntimeout = 3\nvisual = false\nrandom_assignment = true\ndebug = false\nport = 8000\n\n# Optional predefined groups\n[groups]\n\"Group A\" = [\"player1\", \"player2\", \"player3\", \"player4\"]\n\"Group B\" = [\"player5\", \"player6\", \"player7\", \"player8\"]\n\n# Player definitions\n[agents]\nplayer1 = \"python3 team1/player.py\"\nplayer2 = \"python3 team2/player.py\"\nplayer3 = \"java -jar team3/player.jar\"\n# ... more players\n</code></pre>"},{"location":"tournament/configuration/#game-settings","title":"Game Settings","text":""},{"location":"tournament/configuration/#game-type","title":"Game Type","text":"<p>The <code>game</code> field specifies which game to use for the tournament:</p> <pre><code>game = \"tictactoe\"  # Use Tic-tac-toe\n</code></pre> <p>or</p> <pre><code>game = \"laskermorris\"  # Use Lasker Morris\n</code></pre>"},{"location":"tournament/configuration/#game-settings_1","title":"Game Settings","text":"<p>The <code>[settings]</code> section defines game-specific settings:</p> <pre><code>[settings]\ntimeout = 5          # Move timeout in seconds\nvisual = false       # Disable visualization for faster tournament play\nrandom_assignment = true  # Randomize player colors/symbols\ndebug = false        # Disable debug output\nport = 8000          # Web visualization port (if enabled)\n</code></pre> <p>All settings are optional and will use defaults if not specified.</p>"},{"location":"tournament/configuration/#group-definitions","title":"Group Definitions","text":"<p>Groups can be predefined in the configuration or automatically created by the tournament runner.</p>"},{"location":"tournament/configuration/#predefined-groups","title":"Predefined Groups","text":"<p>To predefine groups, use the <code>[groups]</code> section:</p> <pre><code>[groups]\n\"Group A\" = [\"player1\", \"player2\", \"player3\", \"player4\"]\n\"Group B\" = [\"player5\", \"player6\", \"player7\", \"player8\"]\n</code></pre> <p>Each group is defined as an array of player IDs.</p>"},{"location":"tournament/configuration/#automatic-group-creation","title":"Automatic Group Creation","text":"<p>If you don't define groups, the tournament runner will automatically create them based on the number of players:</p> <ul> <li>For the first round, it creates up to 8 groups with roughly equal sizes</li> <li>Group assignments are randomized for fairness</li> </ul>"},{"location":"tournament/configuration/#agent-definitions","title":"Agent Definitions","text":"<p>The <code>[agents]</code> section defines all players participating in the tournament:</p> <pre><code>[agents]\nplayer1 = \"python3 team1/player.py\"\nplayer2 = \"python3 team2/player.py --strategy aggressive\"\nplayer3 = \"java -jar team3/player.jar\"\nplayer4 = \"node team4/player.js\"\n</code></pre> <p>Each entry consists of:</p> <ul> <li>Player ID (e.g., <code>player1</code>)</li> <li>Command to run the player (e.g., <code>\"python3 team1/player.py\"</code>)</li> </ul> <p>The command can include arguments and should match what you would use to run the player directly with the referee.</p>"},{"location":"tournament/configuration/#example-configurations","title":"Example Configurations","text":""},{"location":"tournament/configuration/#basic-tic-tac-toe-tournament","title":"Basic Tic-tac-toe Tournament","text":"<pre><code>game = \"tictactoe\"\n\n[settings]\ntimeout = 3\nvisual = false\nrandom_assignment = true\n\n[agents]\nplayer1 = \"python3 team1/player.py\"\nplayer2 = \"python3 team2/player.py\"\nplayer3 = \"python3 team3/player.py\"\nplayer4 = \"python3 team4/player.py\"\nplayer5 = \"python3 team5/player.py\"\nplayer6 = \"python3 team6/player.py\"\nplayer7 = \"python3 team7/player.py\"\nplayer8 = \"python3 team8/player.py\"\n</code></pre>"},{"location":"tournament/configuration/#lasker-morris-tournament-with-predefined-groups","title":"Lasker Morris Tournament with Predefined Groups","text":"<pre><code>game = \"laskermorris\"\n\n[settings]\ntimeout = 10\nvisual = false\nrandom_assignment = true\n\n[groups]\n\"Group A\" = [\"team1\", \"team2\", \"team3\", \"team4\"]\n\"Group B\" = [\"team5\", \"team6\", \"team7\", \"team8\"]\n\"Group C\" = [\"team9\", \"team10\", \"team11\", \"team12\"]\n\"Group D\" = [\"team13\", \"team14\", \"team15\", \"team16\"]\n\n[agents]\nteam1 = \"python3 submissions/team1/player.py\"\nteam2 = \"python3 submissions/team2/player.py\"\nteam3 = \"python3 submissions/team3/player.py\"\n# ... more teams\n</code></pre>"},{"location":"tournament/configuration/#mixed-language-tournament","title":"Mixed-Language Tournament","text":"<pre><code>game = \"tictactoe\"\n\n[settings]\ntimeout = 5\nvisual = true\nport = 8080\n\n[agents]\npython_team = \"python3 python_player.py\"\njava_team = \"java -jar java_player.jar\"\njs_team = \"node javascript_player.js\"\ncpp_team = \"./cpp_player\"\ngo_team = \"./go_player\"\nrust_team = \"./rust_player\"\n</code></pre>"},{"location":"tournament/configuration/#large-tournament-with-performance-settings","title":"Large Tournament with Performance Settings","text":"<pre><code>game = \"laskermorris\"\n\n[settings]\ntimeout = 3\nvisual = false\nrandom_assignment = true\ndebug = false\n\n# No predefined groups - tournament will create them automatically\n\n[agents]\nteam01 = \"python3 submissions/team01/player.py\"\nteam02 = \"python3 submissions/team02/player.py\"\nteam03 = \"python3 submissions/team03/player.py\"\n# ... many more teams\nteam32 = \"python3 submissions/team32/player.py\"\n</code></pre>"},{"location":"tournament/configuration/#configuration-tips","title":"Configuration Tips","text":""},{"location":"tournament/configuration/#performance-considerations","title":"Performance Considerations","text":"<p>For faster tournament execution:</p> <ul> <li>Set <code>visual = false</code> to disable web visualization</li> <li>Use a shorter timeout (e.g., 3 seconds)</li> <li>Disable debug output with <code>debug = false</code></li> </ul>"},{"location":"tournament/configuration/#group-balance","title":"Group Balance","text":"<p>When defining groups manually:</p> <ul> <li>Keep group sizes equal when possible</li> <li>Aim for 4 players per group for standard round-robin play</li> <li>Ensure each player appears in exactly one group</li> </ul>"},{"location":"tournament/configuration/#command-formatting","title":"Command Formatting","text":"<p>Player commands should:</p> <ul> <li>Include the full path to the player executable/script</li> <li>Include necessary runtime (e.g., <code>python3</code>, <code>java</code>, <code>node</code>)</li> <li>Include any required arguments</li> <li>Use appropriate path separators for your OS</li> </ul>"},{"location":"tournament/configuration/#multiple-game-types","title":"Multiple Game Types","text":"<p>If you want to run tournaments for different games, create separate configuration files:</p> <ul> <li><code>tictactoe_tournament.toml</code></li> <li><code>laskermorris_tournament.toml</code></li> </ul>"},{"location":"tournament/configuration/#configuration-validation","title":"Configuration Validation","text":"<p>The tournament runner validates your configuration and will report errors for:</p> <ul> <li>Missing required fields</li> <li>Invalid game types</li> <li>Unknown player references in groups</li> <li>Duplicate player assignments</li> <li>Invalid settings values</li> </ul> <p>If errors are found, the tournament will not start until they are resolved.</p>"},{"location":"tournament/configuration/#environmental-variables","title":"Environmental Variables","text":"<p>You can use environment variables in your configuration file using the <code>${VAR_NAME}</code> syntax:</p> <pre><code>[agents]\nteam1 = \"python3 ${SUBMISSIONS_DIR}/team1/player.py\"\n</code></pre> <p>This is useful for:</p> <ul> <li>Configuring paths that might change between environments</li> <li>Keeping sensitive information out of configuration files</li> <li>Setting up different tournament environments</li> </ul>"},{"location":"tournament/configuration/#next-steps","title":"Next Steps","text":"<p>After creating your configuration file, proceed to Running Tournaments to learn how to execute the tournament.</p>"},{"location":"tournament/overview/","title":"Tournament Overview","text":"<p>The CS4341 Game Referee includes a powerful tournament system for organizing and running competitions between AI players. This system allows for multi-round tournaments with different formats, automated match scheduling, and comprehensive results tracking.</p>"},{"location":"tournament/overview/#introduction","title":"Introduction","text":"<p>The tournament system is built as a separate Rust application that integrates with the game referee. It provides:</p> <ul> <li>Multi-round tournaments: Progress through preliminary, quarterfinal, semifinal, and final rounds</li> <li>Group management: Organize players into groups for round-robin play</li> <li>Match scheduling: Automatically schedule matches between players</li> <li>Result tracking: Record and analyze match outcomes</li> <li>Statistics: Calculate standings, win rates, and other performance metrics</li> <li>Reporting: Generate detailed tournament reports</li> </ul>"},{"location":"tournament/overview/#tournament-structure","title":"Tournament Structure","text":"<p>The tournament system supports a flexible competition structure:</p>"},{"location":"tournament/overview/#rounds","title":"Rounds","text":"<p>A tournament typically consists of multiple rounds:</p> <ol> <li>First Round: Initial group stage with all participants</li> <li>Second Round: Qualified players from the first round</li> <li>Third Round: Qualified players from the second round</li> <li>Fourth Round: Final qualifying round</li> <li>Final Round: Championship and placement matches</li> </ol>"},{"location":"tournament/overview/#groups","title":"Groups","text":"<p>Within each round, players are organized into groups:</p> <ul> <li>Each group contains a set of players who compete against each other</li> <li>Players in a group typically play a round-robin format (everyone plays against everyone)</li> <li>Top performers from each group advance to the next round</li> <li>Group assignment can be predefined or randomized</li> </ul>"},{"location":"tournament/overview/#matches","title":"Matches","text":"<p>Each match consists of:</p> <ul> <li>Two players competing in a specific game</li> <li>The referee managing the game rules and determining the winner</li> <li>Result recording for tournament standings</li> </ul>"},{"location":"tournament/overview/#advancement","title":"Advancement","text":"<p>Players advance through the tournament based on performance:</p> <ul> <li>Typically, the top 2 players from each group advance to the next round</li> <li>Tiebreakers can be used when multiple players have the same number of points</li> <li>The final round determines the overall tournament rankings</li> </ul>"},{"location":"tournament/overview/#points-system","title":"Points System","text":"<p>The tournament uses a standard points system:</p> <ul> <li>Win: 2 points</li> <li>Draw: 1 point</li> <li>Loss: 0 points</li> </ul> <p>Players are ranked within their groups based on total points earned.</p>"},{"location":"tournament/overview/#tournament-runner","title":"Tournament Runner","text":"<p>The tournament runner is a Rust application located in the <code>tournament/</code> directory. It manages the entire tournament process:</p> <ol> <li>Configuration: Reads tournament settings from a TOML file</li> <li>Initialization: Sets up groups and schedules matches</li> <li>Execution: Runs matches using the referee</li> <li>Progression: Advances players between rounds</li> <li>Results: Records and reports tournament outcomes</li> </ol>"},{"location":"tournament/overview/#key-features","title":"Key Features","text":""},{"location":"tournament/overview/#automated-match-execution","title":"Automated Match Execution","text":"<p>The tournament runner automatically:</p> <ul> <li>Starts referee processes for each match</li> <li>Provides player commands to the referee</li> <li>Captures and parses match results</li> <li>Handles timeouts and errors</li> </ul>"},{"location":"tournament/overview/#randomization","title":"Randomization","text":"<p>The tournament supports randomization for fair competition:</p> <ul> <li>Random group assignments</li> <li>Random player order within matches</li> <li>Random color/symbol assignment</li> </ul>"},{"location":"tournament/overview/#comprehensive-reporting","title":"Comprehensive Reporting","text":"<p>The tournament generates detailed reports:</p> <ul> <li>Match results for each round</li> <li>Group standings</li> <li>Player statistics</li> <li>Tournament progression</li> <li>Final rankings</li> </ul>"},{"location":"tournament/overview/#error-handling","title":"Error Handling","text":"<p>The tournament system includes robust error handling:</p> <ul> <li>Recovery from failed matches</li> <li>Logging of errors and exceptions</li> <li>Continuation despite individual match failures</li> </ul>"},{"location":"tournament/overview/#visualization","title":"Visualization","text":"<p>While the tournament itself runs in the console, individual matches can use the referee's web visualization:</p> <ul> <li>View real-time match progress</li> <li>Analyze player strategies</li> <li>Understand game outcomes</li> </ul>"},{"location":"tournament/overview/#usage-scenarios","title":"Usage Scenarios","text":"<p>The tournament system is designed for various scenarios:</p>"},{"location":"tournament/overview/#classroom-competitions","title":"Classroom Competitions","text":"<ul> <li>Organize competitions between student AI implementations</li> <li>Evaluate relative performance of different algorithms</li> <li>Provide a fair testing environment</li> </ul>"},{"location":"tournament/overview/#algorithm-testing","title":"Algorithm Testing","text":"<ul> <li>Compare different AI approaches in a structured environment</li> <li>Measure performance across multiple matches</li> <li>Identify strengths and weaknesses</li> </ul>"},{"location":"tournament/overview/#research","title":"Research","text":"<ul> <li>Run experiments with different AI techniques</li> <li>Collect comprehensive performance data</li> <li>Analyze strategic patterns</li> </ul>"},{"location":"tournament/overview/#example-tournament","title":"Example Tournament","text":"<p>Here's an example of how a tournament might progress:</p> <ol> <li> <p>First Round:</p> </li> <li> <p>32 players divided into 8 groups of 4</p> </li> <li>Round-robin play within each group</li> <li> <p>Top 2 from each group advance (16 players)</p> </li> <li> <p>Second Round:</p> </li> <li> <p>16 players divided into 4 groups of 4</p> </li> <li>Round-robin play within each group</li> <li> <p>Top 2 from each group advance (8 players)</p> </li> <li> <p>Third Round:</p> </li> <li> <p>8 players divided into 2 groups of 4</p> </li> <li>Round-robin play within each group</li> <li> <p>Top 2 from each group advance (4 players)</p> </li> <li> <p>Fourth Round:</p> </li> <li> <p>4 players in a single group</p> </li> <li>Round-robin play to determine rankings</li> <li> <p>All players advance to final placement matches</p> </li> <li> <p>Final Round:</p> </li> <li>1st vs 2nd: Championship match</li> <li>3rd vs 4th: Third-place match</li> </ol> <p>The result is a comprehensive tournament that tests players against multiple opponents and provides a clear ranking of their performance.</p> <p>See the Tournament Configuration and Running Tournaments guides for more details on setting up and running tournaments.</p>"},{"location":"tournament/running/","title":"Running Tournaments","text":"<p>This guide explains how to run tournaments using the CS4341 Tournament Runner, including command-line options, execution modes, and managing tournament results.</p>"},{"location":"tournament/running/#prerequisites","title":"Prerequisites","text":"<p>Before running a tournament:</p> <ol> <li>Ensure the CS4341 Game Referee is installed</li> <li>Prepare your tournament configuration file (see Tournament Configuration)</li> <li>Ensure all player programs are accessible and executable</li> <li>Make sure the tournament runner is properly built</li> </ol>"},{"location":"tournament/running/#running-the-tournament","title":"Running the Tournament","text":"<p>The tournament runner is a Rust application located in the <code>tournament/</code> directory. You can run it with:</p> <pre><code>cd tournament\ncargo run -- tournament.toml\n</code></pre> <p>Where <code>tournament.toml</code> is your tournament configuration file.</p>"},{"location":"tournament/running/#command-line-options","title":"Command-Line Options","text":"<p>The tournament runner supports several command-line options:</p> <pre><code>cargo run -- [options] &lt;config_file&gt;\n</code></pre>"},{"location":"tournament/running/#logging-options","title":"Logging Options","text":"Option Description Default <code>--quiet</code>, <code>-q</code> Minimal output (errors only) Off <code>--debug</code>, <code>-d</code> Enable debug output Off <code>--no-log</code> Disable logging completely Off"},{"location":"tournament/running/#tournament-options","title":"Tournament Options","text":"Option Description Default <code>--resume</code> Resume a previously interrupted tournament Off <code>--skip-validation</code> Skip validation of player executables Off <code>--random-seed &lt;seed&gt;</code> Set random seed for reproducibility None"},{"location":"tournament/running/#example-commands","title":"Example Commands","text":"<p>Run with minimal output:</p> <pre><code>cargo run -- --quiet tournament.toml\n</code></pre> <p>Run with debug output:</p> <pre><code>cargo run -- --debug tournament.toml\n</code></pre> <p>Resume an interrupted tournament:</p> <pre><code>cargo run -- --resume tournament.toml\n</code></pre>"},{"location":"tournament/running/#tournament-execution-process","title":"Tournament Execution Process","text":"<p>When running a tournament, the system follows these steps:</p> <ol> <li>Configuration Loading: The tournament configuration is parsed from the TOML file</li> <li>Player Validation: Checks that all player commands are valid</li> <li>Group Setup: Creates groups based on configuration or automatically</li> <li>Match Scheduling: Schedules all matches for the first round</li> <li>First Round Execution: Runs all matches in the first round</li> <li>Advancement: Determines which players advance to the next round</li> <li>Subsequent Rounds: Repeats the process for each tournament round</li> <li>Final Placement: Determines final rankings and generates results</li> </ol>"},{"location":"tournament/running/#round-execution","title":"Round Execution","text":"<p>For each round, the tournament runner:</p> <ol> <li>Creates groups for the round</li> <li>Schedules matches within each group</li> <li>Executes all matches</li> <li>Calculates standings and winners</li> <li>Determines which players advance</li> </ol>"},{"location":"tournament/running/#match-execution","title":"Match Execution","text":"<p>For each match, the tournament runner:</p> <ol> <li>Starts the referee process with the appropriate game</li> <li>Provides player commands to the referee</li> <li>Captures the match result</li> <li>Updates tournament standings</li> <li>Records the result in the CSV file</li> </ol>"},{"location":"tournament/running/#tournament-progress-display","title":"Tournament Progress Display","text":"<p>During the tournament, the runner displays:</p>"},{"location":"tournament/running/#group-information","title":"Group Information","text":"<p>At the start of each round:</p> <pre><code>=== Starting First Round ===\n\nGroup A: player1, player2, player3, player4\nGroup B: player5, player6, player7, player8\n...\n</code></pre>"},{"location":"tournament/running/#match-progress","title":"Match Progress","text":"<p>For each match:</p> <pre><code>Running match: player1 vs player2\nplayer1 wins!\n</code></pre>"},{"location":"tournament/running/#round-standings","title":"Round Standings","text":"<p>After each round:</p> <pre><code>=== Current Standings (First Round) ===\n\nGroup A:\nPlayer      W    L    D    Pts\nplayer1     3    0    0    6.0\nplayer2     2    1    0    4.0\nplayer3     1    2    0    2.0\nplayer4     0    3    0    0.0\n\n...\n\nAdvancing to next round:\nFrom Group A: player1, player2\nFrom Group B: player5, player6\n...\n</code></pre>"},{"location":"tournament/running/#final-results","title":"Final Results","text":"<p>At the end of the tournament:</p> <pre><code>=== TOURNAMENT FINAL RESULTS ===\n\n\ud83c\udfc6 CHAMPION: player1\n\ud83e\udd48 RUNNER-UP: player6\n\ud83e\udd49 THIRD PLACE: player2\n    FOURTH PLACE: player5\n\nTournament completed! Full results saved in tournament_results.csv\n</code></pre>"},{"location":"tournament/running/#tournament-results","title":"Tournament Results","text":"<p>The tournament runner generates a CSV file with detailed results:</p> <pre><code>Round,Group,Game Number,Player 1,Player 2,Winner,Is Draw,Error\nFirst Round,Group A,1,player1,player2,player1,false,\nFirst Round,Group A,2,player3,player4,player3,false,\n...\n</code></pre> <p>This file contains:</p> <ul> <li>Round name</li> <li>Group name</li> <li>Game number within the group</li> <li>Player identifiers</li> <li>Winner (if any)</li> <li>Whether the game was a draw</li> <li>Any errors that occurred</li> </ul>"},{"location":"tournament/running/#handling-errors","title":"Handling Errors","text":"<p>The tournament runner includes robust error handling:</p> <ul> <li>Match Errors: If a match fails, the runner logs the error and continues with the next match</li> <li>Player Errors: If a player process fails, the match is awarded to the opponent</li> <li>Referee Errors: If the referee process fails, the match is marked as an error and skipped</li> <li>Tournament Interruption: If the tournament is interrupted, it can be resumed from the last completed match</li> </ul>"},{"location":"tournament/running/#resuming-tournaments","title":"Resuming Tournaments","text":"<p>If a tournament is interrupted, you can resume it:</p> <pre><code>cargo run -- --resume tournament.toml\n</code></pre> <p>The runner will:</p> <ol> <li>Load the existing results from <code>tournament_results.csv</code></li> <li>Determine the last completed match</li> <li>Continue from the next scheduled match</li> </ol>"},{"location":"tournament/running/#tournament-visualization","title":"Tournament Visualization","text":"<p>While the tournament itself runs in the console, individual matches can use the referee's web visualization if the <code>visual</code> setting is enabled:</p> <pre><code>[settings]\nvisual = true\nport = 8080\n</code></pre> <p>This allows observers to watch matches in real-time via a web browser.</p>"},{"location":"tournament/running/#advanced-usage","title":"Advanced Usage","text":""},{"location":"tournament/running/#running-multiple-tournaments","title":"Running Multiple Tournaments","text":"<p>To run multiple tournaments sequentially:</p> <pre><code>cargo run -- tournament1.toml &amp;&amp; cargo run -- tournament2.toml\n</code></pre>"},{"location":"tournament/running/#tournament-automation","title":"Tournament Automation","text":"<p>You can integrate the tournament runner into scripts or CI/CD pipelines:</p> <pre><code>#!/bin/bash\n# Run tournament and capture exit code\ncargo run -- --quiet tournament.toml\nif [ $? -ne 0 ]; then\n    echo \"Tournament failed!\"\n    exit 1\nfi\n\n# Process results\npython3 analyze_results.py\n</code></pre>"},{"location":"tournament/running/#custom-result-analysis","title":"Custom Result Analysis","text":"<p>After the tournament, you can analyze the results with custom scripts:</p> <pre><code>import pandas as pd\n\n# Load tournament results\ndf = pd.read_csv('tournament_results.csv')\n\n# Analyze player performance\nplayer_stats = {}\nfor _, row in df.iterrows():\n    # Process each match result\n    # ...\n\n# Generate custom reports\n# ...\n</code></pre>"},{"location":"tournament/running/#performance-considerations","title":"Performance Considerations","text":"<p>For large tournaments:</p> <ul> <li>Disable visualization (<code>visual = false</code>)</li> <li>Use shorter timeouts to speed up matches</li> <li>Use the <code>--quiet</code> flag to reduce console output</li> <li>Consider running the tournament on a powerful machine with sufficient RAM</li> </ul>"},{"location":"tournament/running/#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues:</p> <ol> <li>No matches running: Check that player commands are correct and executable</li> <li>Slow execution: Consider disabling visualization and reducing timeouts</li> <li>Referee errors: Ensure the referee is properly installed and accessible</li> <li>CSV parsing errors: Check if the results file is corrupted (backup before resuming)</li> <li>Memory issues: For very large tournaments, consider splitting into smaller tournaments</li> </ol>"},{"location":"tournament/running/#next-steps","title":"Next Steps","text":"<p>After running a tournament, you can:</p> <ol> <li>Analyze the results to identify the strongest players</li> <li>Use the match history to improve player algorithms</li> <li>Run additional tournaments with modified parameters</li> <li>Generate reports and visualizations from the results data</li> </ol>"}]}